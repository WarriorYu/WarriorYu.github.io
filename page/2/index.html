<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Stay Hungry. Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="WarriorYu">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="WarriorYu">
<meta property="og:description" content="Stay Hungry. Stay Foolish.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WarriorYu">
<meta name="twitter:description" content="Stay Hungry. Stay Foolish.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>WarriorYu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WarriorYu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">山中莫道无供给，明月清风不用钱</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/学习算法思想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/学习算法思想/" itemprop="url">学习算法思想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-05T10:37:21+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法和数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习算法思想"><a href="#学习算法思想" class="headerlink" title="学习算法思想"></a>学习算法思想</h1><h3 id="第一章：当我们在讨论算法的时候，我们在讨论什么？"><a href="#第一章：当我们在讨论算法的时候，我们在讨论什么？" class="headerlink" title="第一章：当我们在讨论算法的时候，我们在讨论什么？"></a>第一章：当我们在讨论算法的时候，我们在讨论什么？</h3><ol>
<li><p>我们究竟为什么要学习算法</p>
</li>
<li><p>课程介绍 </p>
</li>
</ol>
<h3 id="第二章：排序基础"><a href="#第二章：排序基础" class="headerlink" title="第二章：排序基础"></a>第二章：排序基础</h3><p>​    2-1 选择排序法<br>​    2-2 使用模板（泛型）编写算法<br>​    2-3 随机生成算法测试用例<br>​    2-4 测试算法的性能<br>​    2-5 插入排序法<br>​    2-6 插入排序法的改进<br>​    2-7 更多关于O（n*2）排序算法的思考</p>
<ol>
<li>冒泡排序（n²）：</li>
<li>选择排序（n²）： 在[i..n)未排序的数组里获取最小的值放在已排序数组的后面，即放在i的位置。<br>缺点：两层循环必须都执行完，所以效率低。 </li>
<li>插入排序（n²）：在未排序数组中取第一个数，跟已排序的数组元素比较，插入到合适的位置。<br>优点：在数组近乎有序的情况下，可以O(n)的时间复杂度。设置比O(nlogn)效率还要高。</li>
</ol>
<h3 id="第三章：高级排序问题"><a href="#第三章：高级排序问题" class="headerlink" title="第三章：高级排序问题"></a>第三章：高级排序问题</h3><p>​    3-1 归并排序法<br>​    3-2 归并排序法的实现<br>​    3-3 归并排序法的优化<br>​    3-4 自底向上的归并排序算法<br>​    3-5 快速排序法<br>​    3-6 随机化快速排序法<br>​    3-7 双路快速排序法<br>​    3-8 三路快速排序法<br>​    3-9 归并排序和快速排序的衍生问题</p>
<h3 id="第四章：堆和堆排序"><a href="#第四章：堆和堆排序" class="headerlink" title="第四章：堆和堆排序"></a>第四章：堆和堆排序</h3><p>​    4-1 为什么使用堆<br>​    4-2 堆的基本存储<br>​    4-3 Shift Up<br>​    4-4 Shift Down<br>​    4-5 基础堆排序和Heapify<br>​    4-6 优化的堆排序<br>​    4-7 排序算法总结<br>​    4-8 索引堆<br>​    4-9 索引堆的优化<br>​    4-10 和堆相关的其他问题</p>
<ol>
<li><p><strong>二叉树（Binary Tree）：</strong> 二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>
</li>
<li><p><strong>二叉查找树（Binary Search Tree）：</strong> 二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？这些都依赖于二叉查找树的特殊结构。二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
</li>
<li><p><strong>满二叉树：</strong> 二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。</p>
</li>
<li><p><strong>完全二叉树：</strong> 二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。</p>
</li>
<li><p><strong>二叉堆：</strong> 堆是一个完全二叉树；堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 </p>
<p><strong>实现一个堆：</strong></p>
<ul>
<li><p>将n个元素逐个插入到一个空堆中，时间复杂度 是O(nlogn)。需要开辟额外的空间，空间复杂度是O(n)。</p>
</li>
<li><p>从2/n的位置开始heapify的过程，算法复杂度为O(n)。在原数组实现为堆，空间复杂度是O(1)。</p>
</li>
</ul>
<p><strong>堆的使用：</strong>用于排序，求第K大的元素等。</p>
<ul>
<li>大顶堆</li>
<li>小顶堆</li>
</ul>
<p>堆排序的时间复杂度O(nlogn)</p>
</li>
</ol>
<h3 id="第五章：二分搜索树"><a href="#第五章：二分搜索树" class="headerlink" title="第五章：二分搜索树"></a>第五章：二分搜索树</h3><p>​    5-1 二分查找法<br>​    5-2 二分搜索树基础<br>​    5-3 二分搜索树的节点插入<br>​    5-4 二分搜索书的查找<br>​    5-5 二分搜索树的遍历（深度优先遍历）<br>​    5-6 层序遍历（广度优先遍历）<br>​    5-7 删除最大值，最小值<br>​    5-8 二分搜索树的删除<br>​    5-9 二分搜索树的顺序性<br>​    5-10 二分搜索树的局限性<br>​    5-11 树形问题和更多树。</p>
<ol>
<li><strong>二叉搜索树：</strong>二叉查找树（Binary Search Tree）二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？这些都依赖于二叉查找树的特殊结构<strong>。二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong> </li>
<li>红黑树：平衡二叉树。</li>
</ol>
<h4 id="（这一章往后还没有看）"><a href="#（这一章往后还没有看）" class="headerlink" title="**（这一章往后还没有看）"></a>**（这一章往后还没有看）</h4><h3 id="第六章-并查集"><a href="#第六章-并查集" class="headerlink" title="第六章:并查集"></a>第六章:并查集</h3><p>​    6-1 并查集基础<br>​    6-2 Qucik Find<br>​    6-3 Quick Union<br>​    6-4 基于size的优化<br>​    6-5 基于rank的优化<br>​    6-6 路径压缩</p>
<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章:"></a>第七章:</h3><p>​    7-1 图论基础<br>​    7-2 图的表示<br>​    7-3 相邻点迭代器<br>​    7-4 图的算法框架<br>​    7-5 深度优先遍历和联通分量<br>​    7-6 寻路<br>​    7-7 广度优先遍历和最短路径<br>​    7-8 迷宫生成，ps抠图–更多无权图的应用</p>
<h3 id="第八章：最小生成树"><a href="#第八章：最小生成树" class="headerlink" title="第八章：最小生成树"></a>第八章：最小生成树</h3><p>​    8-1 有权图<br>​    8-2 最小生成树问题和切分定理<br>​    8-3 Prim算法的第一个实现<br>​    8-4 Prim算法的优化<br>​    8-5 优化后的Prim算法的实现<br>​    8-6 Krusk算法<br>​    8-7 最小生成树算法的思考</p>
<h3 id="第九章：最短路径"><a href="#第九章：最短路径" class="headerlink" title="第九章：最短路径"></a>第九章：最短路径</h3><p>​    9-1 最短路径问题和松弛操作<br>​    9-2 Dijkstra算法的思想<br>​    9-3 实现Dijkstra算法<br>​    9-4 负权边和Bellman-Ford算法<br>​    9-5 实现Bellman-Ford算法<br>​    9-6 更多和最短路径相关的思考</p>
<h3 id="第十章：结束语"><a href="#第十章：结束语" class="headerlink" title="第十章：结束语"></a>第十章：结束语</h3><p>​    10-1 总结，算法思想，大家加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/（二）Glide源码解析之缓存机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/（二）Glide源码解析之缓存机制/" itemprop="url">（二）Glide源码解析之缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-05T10:33:21+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（二）Glide源码解析之缓存机制"><a href="#（二）Glide源码解析之缓存机制" class="headerlink" title="（二）Glide源码解析之缓存机制"></a>（二）Glide源码解析之缓存机制</h2><h3 id="1-Glide的缓存介绍："><a href="#1-Glide的缓存介绍：" class="headerlink" title="1.  Glide的缓存介绍："></a>1.  Glide的缓存介绍：</h3><ul>
<li>活动缓存：</li>
<li>内存缓存</li>
<li>磁盘缓存</li>
</ul>
<h3 id="2-缓存Key"><a href="#2-缓存Key" class="headerlink" title="2.  缓存Key :"></a>2.  缓存Key :</h3><p>从Engine的load()方法里开始分析。我们根据下面的代码看Key是怎么生成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 这里有8个参数，其中model是图片的地址</span></span><br><span class="line">  EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">      resourceClass, transcodeClass, options);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出key的生成，是通过图片的地址、宽高以及给图片设置的其他参数一起组合，生成了Key。生成Key主要是通过在EngineKey中重写了equals()和hashCode()方法，保证所有参数相同的情况下，才认为是同一个Key。</p>
<h3 id="3-内存缓存"><a href="#3-内存缓存" class="headerlink" title="3. 内存缓存"></a>3. 内存缓存</h3><p>内存缓存分为两部分</p>
<ul>
<li>活动缓存 （弱引用）</li>
<li>内存缓存</li>
</ul>
<p>当Glide加载完一张图片后，首先会放到活动缓存，当需要从活动缓存移除时，会保存到内存缓存。这样下次加载同一张图片时，不需要从网络或者磁盘上加载，只要内存中有这张图片，就直接在内存中加载。既省了流量，也提高了加载显示图片的效率，因为加载内存中图片是最快的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>)</span><br><span class="line">	.load(<span class="string">""</span>)</span><br><span class="line">	.skipMemoryCache(<span class="keyword">false</span>)<span class="comment">// 默认是使用缓存的，可以自由配置</span></span><br><span class="line">	.into(imageView);</span><br></pre></td></tr></table></figure>
<p>从加载内存缓存的代码开始分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分析点1：活动缓存 </span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//活动缓存里有，则直接回调</span></span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分析点2：内存缓存</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">      <span class="comment">//判断是否需要缓存，不需要的话，直接返回null</span></span><br><span class="line">      <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 分析点1.1   </span></span><br><span class="line">      <span class="comment">//这里</span></span><br><span class="line">      EngineResource&lt;?&gt; active = activeResources.get(key);</span><br><span class="line">      <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//在活动缓存中成功获取到，则+1,这个操作的作用就相当于记录资源的引用次数</span></span><br><span class="line">        active.acquire();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> active;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 分析1.1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveResources</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">    <span class="comment">//ResourceWeakReference 是弱引用，GC的时候，把活动缓存回收</span></span><br><span class="line">    ResourceWeakReference activeRef = activeEngineResources.get(key);</span><br><span class="line">    <span class="keyword">if</span> (activeRef == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">    <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      cleanupActiveReference(activeRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//分析2：内存缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">    <span class="comment">//判断是否需要缓存，不需要的话，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分析点2.1：</span></span><br><span class="line">		<span class="comment">//获取缓存</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//在内存缓存中成功获取到，则+1,这个操作的作用就相当于记录资源的引用次数</span></span><br><span class="line">      cached.acquire();</span><br><span class="line">      <span class="comment">//分析点2.2</span></span><br><span class="line">      <span class="comment">//添加到活动缓存</span></span><br><span class="line">      activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">//从缓存中取出，并且从缓存中删除</span></span><br><span class="line">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">      <span class="comment">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class="line">      result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="keyword">new</span> EngineResource&lt;&gt;(cached, <span class="keyword">true</span> <span class="comment">/*isMemoryCacheable*/</span>, <span class="keyword">true</span> <span class="comment">/*isRecyclable*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析2.1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideBuilder</span> </span>&#123;</span><br><span class="line"><span class="function">Glide <span class="title">build</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">   	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//LruResourceCache extends LruCache,内存缓存是基于LruCache算法实现的</span></span><br><span class="line">      memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析点2.2：</p>
<p>activeResources就是一个弱引用的HashMap，用来缓存正在使用中的图片，我们可以看到，loadFromActiveResources()方法就是从activeResources这个HashMap当中取值的。使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/（一）Glide源码解析之整体流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/（一）Glide源码解析之整体流程/" itemprop="url">（一）Glide源码解析之整体流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-05T10:31:29+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（一）Glide源码解析之整体流程"><a href="#（一）Glide源码解析之整体流程" class="headerlink" title="（一）Glide源码解析之整体流程"></a>（一）Glide源码解析之整体流程</h2><ol>
<li><p>使用Glide，我们就完全不用担心图片内存浪费，甚至是内存溢出的问题。因为Glide从来都不会直接将图片的完整尺寸全部加载到内存中，而是用多少加载多少。Glide会自动判断ImageView的大小，然后只将这么大的图片像素加载到内存当中，帮助我们节省内存开支。 </p>
</li>
<li><p>我们分析这行最简单的加载图片的代码：Glide.wih(this).load(url).into(imageView);</p>
</li>
<li><h4 id="Glide-with-…-方法："><a href="#Glide-with-…-方法：" class="headerlink" title="Glide.with(…)方法："></a>Glide.with(…)方法：</h4><p>with()静态方法，有以下几个重载方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glide</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123; </span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Glide.with(…)方法可以传入Activity、FragmentActivity、android.support.v4.app.Fragment、android.app.Fragment、View。with()方法里面都是通过getRetriever(…)方法得到RequestManagerRetriever对象。然后通过RequestManagerRetriever的get(…)方法得到RequestManager对象。 </p>
</li>
</ol>
<p>   下面我们看看RequestManagerRetriever类里几个重载的get(…)方法，即获取RequestManager的几个相关方法。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManagerRetriever</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"> <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">        <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">      <span class="keyword">return</span> supportFragmentGet(</span><br><span class="line">          activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(fragment.getActivity(),</span><br><span class="line">          <span class="string">"You cannot start a load on a fragment before it is attached or after it is destroyed"</span>);</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(fragment.getActivity().getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">      <span class="keyword">return</span> supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      <span class="keyword">return</span> fragmentGet(</span><br><span class="line">          activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line">    Preconditions.checkNotNull(view.getContext(),</span><br><span class="line">        <span class="string">"Unable to obtain a request manager for a view without a Context"</span>);</span><br><span class="line">    Activity activity = findActivity(view.getContext());</span><br><span class="line">    <span class="comment">// The view might be somewhere else, like a service.</span></span><br><span class="line">    <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Support Fragments.</span></span><br><span class="line">    <span class="comment">// Although the user might have non-support Fragments attached to FragmentActivity, searching</span></span><br><span class="line">    <span class="comment">// for non-support Fragments is so expensive pre O and that should be rare enough that we</span></span><br><span class="line">    <span class="comment">// prefer to just fall back to the Activity directly.</span></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);</span><br><span class="line">      <span class="keyword">return</span> fragment != <span class="keyword">null</span> ? get(fragment) : get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Standard Fragments.</span></span><br><span class="line">    android.app.Fragment fragment = findFragment(view, activity);</span><br><span class="line">    <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Either an application context or we're on a background thread.</span></span><br><span class="line">    <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Normally pause/resume is taken care of by the fragment we add to the fragment or</span></span><br><span class="line">          <span class="comment">// activity. However, in this case since the manager attached to the application will not</span></span><br><span class="line">          <span class="comment">// receive lifecycle events, we must force the manager to start resumed using</span></span><br><span class="line">          <span class="comment">// ApplicationLifecycle.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                  <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applicationManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"deprecation"</span>, <span class="string">"DeprecatedIsStillUsed"</span>&#125;)</span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   上面获取RequestManager对象的方法看着挺多，但是稍微归类一下还挺简单的。RequestManagerRetriever类中看似有很多个get()方法的重载，什么Context参数，Activity参数，Fragment参数等等，实际上只有两种情况而已，即传入Application类型的参数，和传入非Application类型的参数。</p>
<p>   下面我们分析这两种情况：</p>
<ul>
<li>传入Application类型的参数：这种情况会在get(…)方法内部调用getApplicationManager(context)方法，得到RequestManager对象。因为Application的生命周期就是应用的生命周期，即Glide会和应用程序的生命周期同步，不会有其他的特殊处理。如果应用程序关闭，Glide的加载也会同时终止。</li>
<li><p>传入Activity、FragmentActivity、v4包下的Fragment、app包下的Fragment：这种情况最终流程是一样的，都是在get(…)方法里调用fragmentGet(…)或者supportFragmentGet(…)获取RequestManager对象。而且在fragmentGet(…)和supportFragmentGet(…)分别调用了getRequestManagerFragment(fm, parentHint, isParentVisible)和getSupportRequestManagerFragment(fm, parentHint, isParentVisible)在当前的Activity中添加一个隐藏的Fragment。之所以添加Fragment，是因为当我们加载页面、关闭页面等跟生命周期相关的操作时，Glide必须感知到生命周期方法的调用，从而开始加载图片、停止加载图片等操作，即Glide需要监听页面的生命周期方法，但是不能让开发者在每个页面都写Glide跟生命周期相关的方法的代码。又因为Activity和Fragment的生命周期方法是同步的，所有在Activity中添加一个Fragment，专门来处理跟Glide相关的操作，这样开发者无需手动再写Glide和页面生命周期方法相关的代码。即Glide通过在页面中添加Fragment，帮我们处理了生命周期相关的代码。</p>
<p>注意：在非Application参数的get(…)方法里有一个Util.isOnBackgroundThread()的判断，即在非主线程当中使用Glide，不管传入的是Activity或者Fragment，统统当做Application来处理。</p>
<p>总结：Glide.with()方法主要是通过传入的参数来确定图片加载的生命周期，并且得到一个RequestManager对象。</p>
</li>
</ul>
<ol start="4">
<li><h4 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h4><p>因为Glide.with()方法返回的是RequestManager对象，所以load()方法是在RequestManager类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span>,<span class="title">ModelTypes</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">Drawable</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@CheckResult</span></span><br><span class="line">  <span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建了一个RequestBuilder对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@CheckResult</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//model为设置的url</span></span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    <span class="comment">//记录是否设置了url</span></span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> load()方法主要是创建了一个RequestBuilder对象，并且给RequestBuilder设置了要加载的model(url)，并记录url已设置的状态。</p>
</li>
<li><h4 id="into"><a href="#into" class="headerlink" title="into()"></a>into()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">  RequestOptions requestOptions = <span class="keyword">this</span>.requestOptions;</span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Clone in this method so that if we use this RequestBuilder to load into a View and then</span></span><br><span class="line">    <span class="comment">// into a different target, we don't retain the transformation applied based on the previous</span></span><br><span class="line">    <span class="comment">// View's scale type.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个RequestOptions里保存了要设置的scaleType</span></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个transcodeClass是指的drawable或bitmap</span></span><br><span class="line">  <span class="comment">//分析1</span></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      requestOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> &lt;X&gt; <span class="function">ViewTarget&lt;ImageView, X&gt; <span class="title">buildImageViewTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull ImageView imageView, @NonNull Class&lt;X&gt; transcodeClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory responsible for producing the correct type of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> com.bumptech.glide.request.target.Target&#125; for a given &#123;<span class="doctag">@link</span> android.view.View&#125; subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTargetFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">public</span> &lt;Z&gt; <span class="function">ViewTarget&lt;ImageView, Z&gt; <span class="title">buildTarget</span><span class="params">(@NonNull ImageView view,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果你在使用Glide加载图片的时候调用了asBitmap()方法，那么这里就会构建出BitmapImageViewTarget对象</span></span><br><span class="line">    <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">      <span class="comment">//至于DrawableImageViewTarget对象，这个通常都是用不到的，我们可以暂时不用管它。</span></span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Unhandled class: "</span> + clazz + <span class="string">", try .as*(Class).transcode(ResourceTranscoder)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在into()方法中通过buildImageViewTarget(view, transcodeClass)构建了一个ViewTarget对象，然后在into()方法的最后一行，又是一个into()方法，并且把ViewTarget这个对象当做参数，传入到了RequestBuilder中另一个接收Target对象的into()方法当中了。</p>
<p>下面看一下这个into()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull RequestOptions options)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  options = options.autoClone();</span><br><span class="line">  <span class="comment">//分析1：构建一个Request对象，用来加载图片请求。</span></span><br><span class="line">  Request request = buildRequest(target, targetListener, options);</span><br><span class="line"></span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">    request.recycle();</span><br><span class="line">    <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">    <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">    <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">    <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">      <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">      <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">      <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">      previous.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  <span class="comment">//分析2：发起请求</span></span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析1：先来看buildRequest-方法是如何构建Request对象的。"><a href="#分析1：先来看buildRequest-方法是如何构建Request对象的。" class="headerlink" title="分析1：先来看buildRequest()方法是如何构建Request对象的。"></a>分析1：先来看buildRequest()方法是如何构建Request对象的。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestOptions requestOptions)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildRequestRecursive(</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      <span class="comment">/*parentCoordinator=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      transitionOptions,</span><br><span class="line">      requestOptions.getPriority(),</span><br><span class="line">      requestOptions.getOverrideWidth(),</span><br><span class="line">      requestOptions.getOverrideHeight(),</span><br><span class="line">      requestOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestOptions requestOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.</span></span><br><span class="line">  ErrorRequestCoordinator errorRequestCoordinator = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (errorBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//创建errorRequestCoordinator（异常处理对象）</span></span><br><span class="line">    errorRequestCoordinator = <span class="keyword">new</span> ErrorRequestCoordinator(parentCoordinator);</span><br><span class="line">    parentCoordinator = errorRequestCoordinator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//递归建立缩略图请求</span></span><br><span class="line">  Request mainRequest =</span><br><span class="line">    <span class="comment">//分析1：</span></span><br><span class="line">      buildThumbnailRequestRecursive(</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          parentCoordinator,</span><br><span class="line">          transitionOptions,</span><br><span class="line">          priority,</span><br><span class="line">          overrideWidth,</span><br><span class="line">          overrideHeight,</span><br><span class="line">          requestOptions);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (errorRequestCoordinator == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mainRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> errorOverrideWidth = errorBuilder.requestOptions.getOverrideWidth();</span><br><span class="line">  <span class="keyword">int</span> errorOverrideHeight = errorBuilder.requestOptions.getOverrideHeight();</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)</span><br><span class="line">      &amp;&amp; !errorBuilder.requestOptions.isValidOverride()) &#123;</span><br><span class="line">    errorOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class="line">    errorOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Request errorRequest = errorBuilder.buildRequestRecursive(</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      errorRequestCoordinator,</span><br><span class="line">      errorBuilder.transitionOptions,</span><br><span class="line">      errorBuilder.requestOptions.getPriority(),</span><br><span class="line">      errorOverrideWidth,</span><br><span class="line">      errorOverrideHeight,</span><br><span class="line">      errorBuilder.requestOptions);</span><br><span class="line">  errorRequestCoordinator.setRequests(mainRequest, errorRequest);</span><br><span class="line">  <span class="keyword">return</span> errorRequestCoordinator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析1：-buildThumbnailRequestRecursive"><a href="#分析1：-buildThumbnailRequestRecursive" class="headerlink" title="分析1： buildThumbnailRequestRecursive()"></a>分析1： buildThumbnailRequestRecursive()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildThumbnailRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestOptions requestOptions)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thumbnailBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Recursive case: contains a potentially recursive thumbnail request builder.</span></span><br><span class="line">    <span class="keyword">if</span> (isThumbnailBuilt) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"You cannot use a request as both the main request and a "</span></span><br><span class="line">          + <span class="string">"thumbnail, consider using clone() on the request(s) passed to thumbnail()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; thumbTransitionOptions =</span><br><span class="line">        thumbnailBuilder.transitionOptions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply our transition by default to thumbnail requests but avoid overriding custom options</span></span><br><span class="line">    <span class="comment">// that may have been applied on the thumbnail request explicitly.</span></span><br><span class="line">    <span class="keyword">if</span> (thumbnailBuilder.isDefaultTransitionOptionsSet) &#123;</span><br><span class="line">      thumbTransitionOptions = transitionOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Priority thumbPriority = thumbnailBuilder.requestOptions.isPrioritySet()</span><br><span class="line">        ? thumbnailBuilder.requestOptions.getPriority() : getThumbnailPriority(priority);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> thumbOverrideWidth = thumbnailBuilder.requestOptions.getOverrideWidth();</span><br><span class="line">    <span class="keyword">int</span> thumbOverrideHeight = thumbnailBuilder.requestOptions.getOverrideHeight();</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)</span><br><span class="line">        &amp;&amp; !thumbnailBuilder.requestOptions.isValidOverride()) &#123;</span><br><span class="line">      thumbOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class="line">      thumbOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//coordinator是一个协调器，用于协调两个单独的&#123;@link Request&#125;同时加载图像的缩略图和图像的完整尺寸图。</span></span><br><span class="line">    ThumbnailRequestCoordinator coordinator = <span class="keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);</span><br><span class="line">    <span class="comment">//获取一个正常请求对象</span></span><br><span class="line">    Request fullRequest =</span><br><span class="line">        obtainRequest(</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            requestOptions,</span><br><span class="line">            coordinator,</span><br><span class="line">            transitionOptions,</span><br><span class="line">            priority,</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight);</span><br><span class="line">    isThumbnailBuilt = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// Recursively generate thumbnail requests.</span></span><br><span class="line">    <span class="comment">//递归建议一个缩略图请求对象</span></span><br><span class="line">    Request thumbRequest =</span><br><span class="line">        thumbnailBuilder.buildRequestRecursive(</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            coordinator,</span><br><span class="line">            thumbTransitionOptions,</span><br><span class="line">            thumbPriority,</span><br><span class="line">            thumbOverrideWidth,</span><br><span class="line">            thumbOverrideHeight,</span><br><span class="line">            thumbnailBuilder.requestOptions);</span><br><span class="line">    isThumbnailBuilt = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 能够同时加载缩略图和正常的图的请求</span></span><br><span class="line">    coordinator.setRequests(fullRequest, thumbRequest);</span><br><span class="line">    <span class="keyword">return</span> coordinator;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (thumbSizeMultiplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span></span><br><span class="line">    <span class="comment">// 当设置了缩略的比例thumbSizeMultiplier(0 ~  1)时，</span></span><br><span class="line">    <span class="comment">// 不需要递归建立缩略图请求</span></span><br><span class="line">    ThumbnailRequestCoordinator coordinator = <span class="keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);</span><br><span class="line">    Request fullRequest =</span><br><span class="line">        obtainRequest(</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            requestOptions,</span><br><span class="line">            coordinator,</span><br><span class="line">            transitionOptions,</span><br><span class="line">            priority,</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight);</span><br><span class="line">    RequestOptions thumbnailOptions = requestOptions.clone()</span><br><span class="line">        .sizeMultiplier(thumbSizeMultiplier);</span><br><span class="line"></span><br><span class="line">    Request thumbnailRequest =</span><br><span class="line">        obtainRequest(</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            thumbnailOptions,</span><br><span class="line">            coordinator,</span><br><span class="line">            transitionOptions,</span><br><span class="line">            getThumbnailPriority(priority),</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight);</span><br><span class="line"></span><br><span class="line">    coordinator.setRequests(fullRequest, thumbnailRequest);</span><br><span class="line">    <span class="keyword">return</span> coordinator;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Base case: no thumbnail.</span></span><br><span class="line">    <span class="comment">// 没有缩略图请求时，直接获取一个正常图请求</span></span><br><span class="line">    <span class="keyword">return</span> obtainRequest(</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        requestOptions,</span><br><span class="line">        parentCoordinator,</span><br><span class="line">        transitionOptions,</span><br><span class="line">        priority,</span><br><span class="line">        overrideWidth,</span><br><span class="line">        overrideHeight);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Request <span class="title">obtainRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">      RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">      RequestOptions requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">      RequestCoordinator requestCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">      TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> overrideHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingleRequest.obtain(</span><br><span class="line">        context,</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        transcodeClass,</span><br><span class="line">        requestOptions,</span><br><span class="line">        overrideWidth,</span><br><span class="line">        overrideHeight,</span><br><span class="line">        priority,</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        requestListeners,</span><br><span class="line">        requestCoordinator,</span><br><span class="line">        glideContext.getEngine(),</span><br><span class="line">        transitionOptions.getTransitionFactory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buildRequest()–&gt;buildRequestRecursive()–&gt; buildThumbnailRequestRecursive()</p>
<p>这个过程里大部分是处理缩略图的，我们主要看一下最后一行的obtainRequest(…)方法，这个方法需要很多参数，比如requestOptions这个参数里有我们设置的placeholderId。diskCacheStrategy等等。</p>
<p>以上into()方法总的过程就是在buildRequest()方法里建立了请求，且最多可同时进行缩略图和正常图的请求，into()方法的最后，调用了requestManager.track(target, request)方法。</p>
<p>接着看看<strong>RequestManager.track(target, request)</strong>里面做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track</span><span class="params">(@NonNull Target&lt;?&gt; target, @NonNull Request request)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 加入一个target目标集合(Set)</span></span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RequestTracker.runRequest(@NonNull Request request)</strong></p>
<p>这里有一个简单的逻辑判断，就是先判断Glide当前是不是处理暂停状态，如果不是暂停状态就调用Request的begin()方法来执行Request；否则的话就先清空请求，将Request添加到待执行的延迟请求队列里面，等暂停状态解除了之后再执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts tracking the given request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(@NonNull Request request)</span> </span>&#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    <span class="comment">//如果不是暂停状态，则开始请求</span></span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request.clear();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Paused, delaying request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再看<strong>SingleRequest.begin()方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  assertNotCallingCallbacks();</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="comment">//model(url)为空，则回调加载失败</span></span><br><span class="line">  <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">"Received null model"</span>), logLevel);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot restart a running request"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we're restarted after we're complete (usually via something like a notifyDataSetChanged</span></span><br><span class="line">  <span class="comment">// that starts an identical request into the same Target or View), we can simply use the</span></span><br><span class="line">  <span class="comment">// resource and size we retrieved the last time around and skip obtaining a new size, starting a</span></span><br><span class="line">  <span class="comment">// new load etc. This does mean that users who want to restart a load because they expect that</span></span><br><span class="line">  <span class="comment">// the view size has changed will need to explicitly clear the View or Target before starting</span></span><br><span class="line">  <span class="comment">// the new load.</span></span><br><span class="line">  <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">    onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restarts for requests that are neither complete nor running can be treated as new requests</span></span><br><span class="line">  <span class="comment">// and can run again from the beginning.</span></span><br><span class="line"></span><br><span class="line">  status = Status.WAITING_FOR_SIZE;</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">    <span class="comment">//当调用RequestOptions.override(int width, int height)设置图片为固定的宽高时，直接执行下面的onSizeReady。</span></span><br><span class="line">    <span class="comment">//并且真正的请求就在onSizeReady方法里</span></span><br><span class="line">    onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据imageView的宽高算出图片的宽高，这个方法最终也会调用onSizeReady</span></span><br><span class="line">    target.getSize(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">      &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">    <span class="comment">//预先加载设置的缩略图</span></span><br><span class="line">    target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestTracker.runRequest(…) -&gt; SingleRequest.begin() -&gt; onSizeReady()至此开始了真正的请求。 </p>
</li>
</ol>
<p>   接下来看<strong>SingleRequest.onSizeReady(…)</strong>方法</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A callback method that should never be invoked directly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(<span class="string">"Got onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">  <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">  <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(<span class="string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据给定的配置进行加载，engine是一个负责加载、管理活跃和缓存资源的引擎类</span></span><br><span class="line">  loadStatus = engine.load(</span><br><span class="line">      glideContext,</span><br><span class="line">      model,</span><br><span class="line">      requestOptions.getSignature(),</span><br><span class="line">      <span class="keyword">this</span>.width,</span><br><span class="line">      <span class="keyword">this</span>.height,</span><br><span class="line">      requestOptions.getResourceClass(),</span><br><span class="line">      transcodeClass,</span><br><span class="line">      priority,</span><br><span class="line">      requestOptions.getDiskCacheStrategy(),</span><br><span class="line">      requestOptions.getTransformations(),</span><br><span class="line">      requestOptions.isTransformationRequired(),</span><br><span class="line">      requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">      requestOptions.getOptions(),</span><br><span class="line">      requestOptions.isMemoryCacheable(),</span><br><span class="line">      requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">      requestOptions.getUseAnimationPool(),</span><br><span class="line">      requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">      <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   该方法内部调用engine.load()开始了真正的请求。 </p>
<p>   下面看<strong>Engine.load()</strong>方法</p>
<p>   这里说一点前置的知识点，Glide的缓存有内存、磁盘、网络三级；内存缓存又可以分为活动缓存、内存缓存两级。</p>
<p>   <strong>Glide之内存缓存（LRU算法）:</strong></p>
<ul>
<li>活动缓存：给正在使用的资源存储的，弱引用。</li>
<li>内存缓存：为第二次缓存服务，LRU算法。 </li>
<li>LRU算法：最近没有使用的元素，会自动被移除掉</li>
<li>LruCache v4：利用LinkedHashMap&lt;K, V&gt;，LinkedHashMap: true==拥有访问排序的功能 (最少使用元素算法-LRU算法)</li>
</ul>
<pre><code>**Glide之磁盘缓存** 
</code></pre><ul>
<li>保存时长比较长：保存在本地磁盘 文件的形式存储 （不再是保存在运行内存中，而是磁盘中） </li>
<li>LRU算法: 最近没有使用的元素，会自动被移除掉</li>
<li>LruCahce – Android中提供了 V4</li>
<li>DiskLruCache — Android中没有提供了 –&gt; DiskLruCache</li>
<li>DiskLruCache：回收方式：LRU算法， 访问排序</li>
<li><p>DiskLruCache: 面向磁盘文件保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,<span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">		<span class="comment">//1. 先获取活动缓存，如果有的话，回调onResourceReady(...)并返回。</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//2. 如果没有活动缓存，再从内存中找，如果有的话， put到Map&lt;Key, ResourceWeakReference&gt;	(内部维护的弱引用缓存map)</span></span><br><span class="line">    <span class="comment">//并且回调 onResourceReady(...)并返回。 </span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">      current.addCallback(cb);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果内存中没有，则创建engineJob（decodejob的回调类，管理下载过程以及状态）</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line">		<span class="comment">// 创建解析工作对象</span></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放在Jobs内部维护的HashMap中</span></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">		<span class="comment">// 注册ResourceCallback接口</span></span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    <span class="comment">// 内部开启线程去请求</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>engineJob.start(decodeJob)</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EngineJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DecodeJob</span>.<span class="title">Callback</span>&lt;<span class="title">R</span>&gt;,<span class="title">Poolable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    	<span class="comment">//根据不同的情况返回下面四种不同的线程池</span></span><br><span class="line">      <span class="comment">//GlideExecutor diskCacheExecutor;</span></span><br><span class="line">		  <span class="comment">//GlideExecutor sourceExecutor;</span></span><br><span class="line">		  <span class="comment">//GlideExecutor sourceUnlimitedExecutor;</span></span><br><span class="line">		  <span class="comment">//GlideExecutor animationExecutor;</span></span><br><span class="line">      GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">          ? diskCacheExecutor</span><br><span class="line">          : getActiveSourceExecutor();</span><br><span class="line">      executor.execute(decodeJob);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EngineJob是一个通过为图片的加载添加和移除callbacks来管理图片加载，并在加载完成后通知callbacks的类。</p>
<p>它的主要作用就是用来开启线程的，为后面的异步加载图片做准备。DecodeJob对象，从名字上来看，它好像是用来对图片进行解码的，但实际上它的任务十分繁重，Engine.load()最后调用了EngineJob的start()方法来运行DecodeJob对象，这实际上就是让DecodeJob的run()方法在子线程当中执行了。 </p>
<p>DecodeJob.run()方法又调用了runWrapped()，我们来看<strong>runWrapped()</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      <span class="comment">//分析1：</span></span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      <span class="comment">//分析2：</span></span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">    	<span class="comment">//分析3：</span></span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析1：完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private DataFetcherGenerator getNextGenerator() &#123;</span><br><span class="line">  switch (stage) &#123;</span><br><span class="line">    case RESOURCE_CACHE:</span><br><span class="line">      return new ResourceCacheGenerator(decodeHelper, this);</span><br><span class="line">    case DATA_CACHE:</span><br><span class="line">      return new DataCacheGenerator(decodeHelper, this);</span><br><span class="line">    case SOURCE:</span><br><span class="line">      return new SourceGenerator(decodeHelper, this);</span><br><span class="line">    case FINISHED:</span><br><span class="line">      return null;</span><br><span class="line">    default:</span><br><span class="line">      throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析2： runGenerators()里面调用了<strong>startNext()</strong>。</p>
<p>startNext()是接口类DataFetcherGenerator里的抽象方法，在SourceGenerator、DataCacheGenerator、ResourceCacheGenerator分别重写了startNext()，这三个类分别对应着图片的原始数据、缓存文件里原始未修改的数据、缓存文件里经过采样\变换的数据。</p>
<p>下面我们看一下从网络加载图片时，也就是<strong>SourceGenerator.startNext()</strong>方法</p>
<p>根据磁盘缓存策略，先将源数据写入磁盘，然后从缓存文件中加载而不是直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//dataToCache数据不为空的话缓存到硬盘</span></span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    cacheData(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    <span class="comment">//分析1：</span></span><br><span class="line">    <span class="comment">//getLoadData()方法内部会在modelLoaders里面找到ModelLoder对象</span></span><br><span class="line">    <span class="comment">// （每个Generator对应一个ModelLoader），</span></span><br><span class="line">    <span class="comment">// 并使用modelLoader.buildLoadData方法返回一个loadData列表</span></span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//分析2 </span></span><br><span class="line">      <span class="comment">//通过loadData对象的fetcher对象（其实现类为HttpUrlFetcher）的</span></span><br><span class="line">      <span class="comment">// loadData方法来获取图片数据</span></span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeHelper</span>&lt;<span class="title">Transcode</span>&gt;</span>&#123;</span><br><span class="line">  List&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoadDataSet) &#123;</span><br><span class="line">      isLoadDataSet = <span class="keyword">true</span>;</span><br><span class="line">      loadData.clear();</span><br><span class="line">      List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">      <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = modelLoaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">        <span class="comment">// 注意：这里最终是通过HttpGlideUrlLoader的buildLoadData获取到实际的loadData对象</span></span><br><span class="line">        LoadData&lt;?&gt; current =modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          loadData.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loadData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpGlideUrlLoader.buildLoadData(…)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(@NonNull GlideUrl model, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Options options)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span></span><br><span class="line">  <span class="comment">// spent parsing urls.</span></span><br><span class="line">  <span class="comment">//GlideUrls会记住已解析的URL，因此对它们进行缓存可以节省一些对象实例化和解析URL所花费的时间。</span></span><br><span class="line">  GlideUrl url = model;</span><br><span class="line">  <span class="keyword">if</span> (modelCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//分析1.1：</span></span><br><span class="line">      modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">      url = model;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> timeout = options.get(TIMEOUT);</span><br><span class="line">  <span class="comment">//在这里创建了一个DataFetcher的实现类HttpUrlFetcher</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(url, <span class="keyword">new</span> HttpUrlFetcher(url, timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析1.1：modelCache.put(…)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model  The model.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width  The width in pixels of the view the image is being loaded into.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height The height in pixels of the view the image is being loaded into.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value  The value to store.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(A model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, B value)</span> </span>&#123;</span><br><span class="line">  ModelKey&lt;A&gt; key = ModelKey.get(model, width, height);</span><br><span class="line">  <span class="comment">// 最终是通过LruCache来缓存对应的值，key是一个ModelKey对象（由model、width、height三个属性组成）</span></span><br><span class="line">  cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里的分析，我们明白了HttpUrlFetcher实际上就是最终的请求执行者，而且，我们知道了Glide会使用LruCache来对解析后的url来进行缓存，以便后续可以省去解析url的时间。</p>
<p>分析2：HttpUrlFetcher.loadData(…)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//分析1 loadDataWithRedirects内部是通过HttpURLConnection网络请求数据</span></span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">    <span class="comment">// 请求成功回调onDataReady()</span></span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to load data for url"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Finished http url fetcher fetch in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析1：HttpUrlFetcher.loadDataWithRedirects(…) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(URL url, <span class="keyword">int</span> redirects, URL lastUrl,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Too many (&gt; "</span> + MAXIMUM_REDIRECTS + <span class="string">") redirects!"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Comparing the URLs using .equals performs additional network I/O and is generally broken.</span></span><br><span class="line">    <span class="comment">// See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastUrl != <span class="keyword">null</span> &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"In re-direct loop"</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">      <span class="comment">// Do nothing, this is best effort.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  urlConnection = connectionFactory.build(url);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  urlConnection.setConnectTimeout(timeout);</span><br><span class="line">  urlConnection.setReadTimeout(timeout);</span><br><span class="line">  urlConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">  urlConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop the urlConnection instance of HttpUrlConnection from following redirects so that</span></span><br><span class="line">  <span class="comment">// redirects will be handled by recursive calls to this method, loadDataWithRedirects.</span></span><br><span class="line">  urlConnection.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect explicitly to avoid errors in decoders if connection fails.</span></span><br><span class="line">  urlConnection.connect();</span><br><span class="line">  <span class="comment">// Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.</span></span><br><span class="line">  stream = urlConnection.getInputStream();</span><br><span class="line">  <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> statusCode = urlConnection.getResponseCode();</span><br><span class="line">  <span class="comment">//2xx的状态码，代表请求成功</span></span><br><span class="line">  <span class="keyword">if</span> (isHttpOk(statusCode)) &#123;</span><br><span class="line">    <span class="comment">//从urlConnection中获取资源流</span></span><br><span class="line">    <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHttpRedirect(statusCode)) &#123;</span><br><span class="line">    <span class="comment">//重定向请求</span></span><br><span class="line">    String redirectUrlString = urlConnection.getHeaderField(<span class="string">"Location"</span>);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Received empty or null redirect url"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    URL redirectUrl = <span class="keyword">new</span> URL(url, redirectUrlString);</span><br><span class="line">    <span class="comment">// Closing the stream specifically is required to avoid leaking ResponseBodys in addition</span></span><br><span class="line">    <span class="comment">// to disconnecting the url connection below. See #2352.</span></span><br><span class="line">    cleanup();</span><br><span class="line">    <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == INVALID_STATUS_CODE) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(statusCode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(urlConnection.getResponseMessage(), statusCode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">getStreamForSuccessfulRequest</span><span class="params">(HttpURLConnection urlConnection)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(urlConnection.getContentEncoding())) &#123;</span><br><span class="line">      <span class="keyword">int</span> contentLength = urlConnection.getContentLength();</span><br><span class="line">      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Got non empty content encoding: "</span> + urlConnection.getContentEncoding());</span><br><span class="line">      &#125;</span><br><span class="line">      stream = urlConnection.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpUrlFetcher.loadData(…)方法主要是通过调用loadDataWithRedirects(…)方法，使用原生的HttpURLConnection进行网络请求后，调用getStreamForSuccessfulRequest()方法获取最终的图片流。</p>
</li>
</ul>
<ol start="6">
<li><p>现在我们回到DecodeJob类中的run() -&gt;runWrapped() </p>
<p>下面我们再次贴出runWrapped()方法的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      <span class="comment">// 分析1：</span></span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析1：我们在刚才获取到图片的流后，还需要<strong>decodeFromRetrievedData()</strong>方法对流进行处理以得到我们想要的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">    logWithTimeAndKey(<span class="string">"Retrieved data"</span>, startFetchTime,</span><br><span class="line">        <span class="string">"data: "</span> + currentData</span><br><span class="line">            + <span class="string">", cache key: "</span> + currentSourceKey</span><br><span class="line">            + <span class="string">", fetcher: "</span> + currentFetcher);</span><br><span class="line">  &#125;</span><br><span class="line">  Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//从数据中解码得到资源</span></span><br><span class="line">    resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">    e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">    throwables.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 编码和发布最终得到的Resource&lt;Bitmap&gt;对象</span></span><br><span class="line">    notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runGenerators();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromData</span><span class="params">(DataFetcher&lt;?&gt; fetcher, Data data,</span></span></span><br><span class="line"><span class="function"><span class="params">      DataSource dataSource)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">      <span class="comment">//执行解码的方法</span></span><br><span class="line">      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Decoded result "</span> + result, startTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromFetcher</span><span class="params">(Data data, DataSource dataSource)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">    <span class="comment">//将解码任务分发给LoadPath</span></span><br><span class="line">    <span class="keyword">return</span> runLoadPath(data, dataSource, path);</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">private</span> &lt;Data, ResourceType&gt; <span class="function">Resource&lt;R&gt; <span class="title">runLoadPath</span><span class="params">(Data data, DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">        LoadPath&lt;Data, ResourceType, R&gt; path)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">      Options options = getOptionsWithHardwareConfig(dataSource);</span><br><span class="line">    	<span class="comment">// 将数据进一步包装</span></span><br><span class="line">      DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ResourceType in DecodeCallback below is required for compilation to work with gradle.</span></span><br><span class="line">        <span class="comment">//分析1：</span></span><br><span class="line">        <span class="comment">//将解码任务分发给LoadPath类里的load(...)方法</span></span><br><span class="line">        <span class="keyword">return</span> path.load(</span><br><span class="line">            rewinder, options, width, height, <span class="keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rewinder.cleanup();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析1：<strong>LoadPath.load(…)</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadPath</span>&lt;<span class="title">Data</span>, <span class="title">ResourceType</span>, <span class="title">Transcode</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">load</span><span class="params">(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//分析2：</span></span><br><span class="line">      <span class="keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      listPool.release(throwables);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;Transcode&gt; <span class="title">loadWithExceptionList</span><span class="params">(DataRewinder&lt;Data&gt; rewinder,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width, <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;Transcode&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;</span><br><span class="line">      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//分析3</span></span><br><span class="line">        <span class="comment">//将解码任务又进一步分发给DecodePath的decode方法去解码</span></span><br><span class="line">        result = path.decode(rewinder, width, height, options, decodeCallback);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">        exceptions.add(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> GlideException(failureMessage, <span class="keyword">new</span> ArrayList&lt;&gt;(exceptions));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析3：<strong>DecodePath.decode(…)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodePath</span>&lt;<span class="title">DataType</span>, <span class="title">ResourceType</span>, <span class="title">Transcode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//继续调用DecodePath的decodeResource方法去解析出数据</span></span><br><span class="line">      Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">      Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">      <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResource</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height, @NonNull Options options)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//分析4：</span></span><br><span class="line">      <span class="keyword">return</span> decodeResourceWithList(rewinder, width, height, options, exceptions);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      listPool.release(exceptions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResourceWithList</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height, @NonNull Options options, List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;ResourceType&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;</span><br><span class="line">      ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        DataType data = rewinder.rewindAndGet();</span><br><span class="line">        <span class="keyword">if</span> (decoder.handles(data, options)) &#123;</span><br><span class="line">          <span class="comment">//获取包装的数据</span></span><br><span class="line">          data = rewinder.rewindAndGet();</span><br><span class="line">          <span class="comment">// 根据data（DataType）和ResourceType的类型分发给不同的解码器Decoder</span></span><br><span class="line">          result = decoder.decode(data, width, height, options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but</span></span><br><span class="line">        <span class="comment">// instead log and continue. See #2406 for an example.</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">          Log.v(TAG, <span class="string">"Failed to decode data for "</span> + decoder, e);</span><br><span class="line">        &#125;</span><br><span class="line">        exceptions.add(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> GlideException(failureMessage, <span class="keyword">new</span> ArrayList&lt;&gt;(exceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，经过一连串的嵌套调用，最终执行到了decoder.decode()这行代码，decode是一个ResourceDecoder&lt;DataType, ResourceType&gt;资源解码器接口，根据不同的DataType和ResourceType它会有不同的实现类，这里的实现类是ByteBufferBitmapDecoder，接下来让我们来看看这个解码器内部的解码流程。</p>
<p> <strong>ByteBufferBitmapDecoder.decode(…)</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decodes &#123;<span class="doctag">@link</span> android.graphics.Bitmap Bitmaps&#125; from &#123;<span class="doctag">@link</span> java.nio.ByteBuffer ByteBuffers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferBitmapDecoder</span> <span class="keyword">implements</span> <span class="title">ResourceDecoder</span>&lt;<span class="title">ByteBuffer</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Downsampler downsampler;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(@NonNull ByteBuffer source, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Options options)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream is = ByteBufferUtil.toStream(source);</span><br><span class="line">    <span class="comment">//核心代码</span></span><br><span class="line">    <span class="keyword">return</span> downsampler.decode(is, width, height, options);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终是使用了一个downsampler，它是一个压缩器，主要是对流进行解码，压缩，圆角等处理。</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public final class Downsampler &#123;</span><br><span class="line"> public Resource&lt;Bitmap&gt; decode(InputStream is, int outWidth, int outHeight,</span><br><span class="line">      Options options) throws IOException &#123;</span><br><span class="line">    return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //根据给定的is解码成Bitmap</span><br><span class="line">   public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight,</span><br><span class="line">      Options options, DecodeCallbacks callbacks) throws IOException &#123;</span><br><span class="line">    Preconditions.checkArgument(is.markSupported(), &quot;You must provide an InputStream that supports&quot;</span><br><span class="line">        + &quot; mark()&quot;);</span><br><span class="line"></span><br><span class="line">    byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);</span><br><span class="line">    BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();</span><br><span class="line">    bitmapFactoryOptions.inTempStorage = bytesForOptions;</span><br><span class="line"></span><br><span class="line">    DecodeFormat decodeFormat = options.get(DECODE_FORMAT);</span><br><span class="line">    DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);</span><br><span class="line">    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);</span><br><span class="line">    boolean isHardwareConfigAllowed =</span><br><span class="line">      options.get(ALLOW_HARDWARE_CONFIG) != null &amp;&amp; options.get(ALLOW_HARDWARE_CONFIG);</span><br><span class="line">		//核心代码</span><br><span class="line">    try &#123;</span><br><span class="line">      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,</span><br><span class="line">          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,</span><br><span class="line">          requestedHeight, fixBitmapToRequestedDimensions, callbacks);</span><br><span class="line">      //将Bitmap包装成BitmapResource  </span><br><span class="line">      return BitmapResource.obtain(result, bitmapPool);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      releaseOptions(bitmapFactoryOptions);</span><br><span class="line">      byteArrayPool.put(bytesForOptions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private Bitmap decodeFromWrappedStreams(InputStream is,</span><br><span class="line">      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,</span><br><span class="line">      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,</span><br><span class="line">      int requestedHeight, boolean fixBitmapToRequestedDimensions,</span><br><span class="line">      DecodeCallbacks callbacks) throws IOException &#123;</span><br><span class="line">   </span><br><span class="line">    //省略计算压缩比例等操作</span><br><span class="line">     ... </span><br><span class="line">     </span><br><span class="line">    Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);</span><br><span class="line">    callbacks.onDecodeComplete(bitmapPool, downsampled);</span><br><span class="line"></span><br><span class="line">    //Bitmap旋转处理</span><br><span class="line">    ...</span><br><span class="line">    return rotated;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options,</span><br><span class="line">      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException &#123;</span><br><span class="line">      </span><br><span class="line">		...</span><br><span class="line">		final Bitmap result;</span><br><span class="line">    TransformationUtils.getBitmapDrawableLock().lock();</span><br><span class="line">    try &#123;</span><br><span class="line">    	//核心代码</span><br><span class="line">      result = BitmapFactory.decodeStream(is, null, options);</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      TransformationUtils.getBitmapDrawableLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (options.inJustDecodeBounds) &#123;</span><br><span class="line">      is.reset();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   从以上源码流程我们知道，最后是在DownSampler的decodeStream()方法中使用了BitmapFactory.decodeStream()来得到Bitmap对象。然后，我们来分析下图片时如何显示的，我们回到DownSampler.decode()方法，看到关注点7，这里是将Bitmap包装成BitmapResource对象返回，通过内部的get方法可以得到Bitmap对象，再回到DecodeJob.run()方法，这是使用了notifyEncodeAndRelease()方法对Resource对象进行了发布。</p>
<p>   我们再回到上面分析的<strong>HttpUrlFetcher.loadData(…)</strong>方法</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//loadDataWithRedirects内部是通过HttpURLConnection网络请求数据</span></span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">    <span class="comment">// 分析1：请求成功回调onDataReady()</span></span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to load data for url"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Finished http url fetcher fetch in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   分析1: <strong>onDataReady(result)</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceGenerator</span> <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>,</span></span><br><span class="line"><span class="class">    <span class="title">DataFetcher</span>.<span class="title">DataCallback</span>&lt;<span class="title">Object</span>&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">      dataToCache = data;</span><br><span class="line">      <span class="comment">// We might be being called back on someone else's thread. Before doing anything, we should</span></span><br><span class="line">      <span class="comment">// reschedule to get back onto Glide's thread.</span></span><br><span class="line">      cb.reschedule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分析2：通知回调加载已完成</span></span><br><span class="line">      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">          loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   ​    </p>
<pre><code>分析2：**onDataFetcherReady(...)**
</code></pre>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,</span></span></span><br><span class="line"><span class="function"><span class="params">      DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentSourceKey = sourceKey;</span><br><span class="line">    <span class="keyword">this</span>.currentData = data;</span><br><span class="line">    <span class="keyword">this</span>.currentFetcher = fetcher;</span><br><span class="line">    <span class="keyword">this</span>.currentDataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">      <span class="comment">//分析3：</span></span><br><span class="line">      runReason = RunReason.DECODE_DATA;</span><br><span class="line">      callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      GlideTrace.beginSection(<span class="string">"DecodeJob.decodeFromRetrievedData"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        decodeFromRetrievedData();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        GlideTrace.endSection();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">        decodeFromRetrievedData();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">      e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">      throwables.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//1</span></span><br><span class="line">      notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runGenerators();</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line">    notifyComplete(result, dataSource);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Call onEncodeComplete outside the finally block so that it's not called if the encode process</span></span><br><span class="line">    <span class="comment">// throws.</span></span><br><span class="line">    onEncodeComplete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyComplete</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    setNotifiedOrThrow();</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    callback.onResourceReady(resource, dataSource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   分析3：在这里我们看到了RunReason.DECODE_DATA，这个枚举代表处理返回的图片资源。然后调用了callback.reschedule(this);然后就会重新执行DecodeJob里的run()-&gt;runWrapped()，因为刚才runReason=DECODE_DATA，所以下一步会执行到decodeFromRetrievedData()方法。经过1.notifyEncodeAndRelease(…) -&gt;2. notifyComplete(…) -&gt;  3.callback.onResourceReady(…)。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EngineJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DecodeJob</span>.<span class="title">Callback</span>&lt;<span class="title">R</span>&gt;,<span class="title">Poolable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//成功加载资源时调用。</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    <span class="comment">//通过Handler发送消息MSG_COMPLETE到主线程</span></span><br><span class="line">    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, <span class="keyword">this</span>).sendToTarget();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synthetic</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    MainThreadCallback() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">      EngineJob&lt;?&gt; job = (EngineJob&lt;?&gt;) message.obj;</span><br><span class="line">      <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_COMPLETE:</span><br><span class="line">          <span class="comment">//在主线程处理结果</span></span><br><span class="line">          job.handleResultOnMainThread();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleResultOnMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    ...</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = cbs.size(); i &lt; size; i++) &#123;</span><br><span class="line">      ResourceCallback cb = cbs.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class="line">        engineResource.acquire();</span><br><span class="line">        <span class="comment">//这里通过for循环调用了所有的ResourceCallback的方法。</span></span><br><span class="line">        cb.onResourceReady(engineResource, dataSource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   那这里的ResourceCallback是一个接口，那么是在哪里实现的这个接口呢？下面我们梳理一下</p>
<p>   首先看一下SingleRequest的onSizeReady()，这个方法里调用了engine.load(…,this)，并将this（SingleRequest）作为参数，又因为SingleRequest实现了ResourceCallback，所以，上面for循环里回调的onResourceReady(…)方法，就是SingleRequest重写的onResourceReady(…)方法。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//ResourceCallback在这里进行了注册</span></span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleRequest</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Request</span>,</span></span><br><span class="line"><span class="class">    <span class="title">SizeReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ResourceCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">FactoryPools</span>.<span class="title">Poolable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    loadStatus = engine.load(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        requestOptions.getSignature(),</span><br><span class="line">        <span class="keyword">this</span>.width,</span><br><span class="line">        <span class="keyword">this</span>.height,</span><br><span class="line">        requestOptions.getResourceClass(),</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        requestOptions.getDiskCacheStrategy(),</span><br><span class="line">        requestOptions.getTransformations(),</span><br><span class="line">        requestOptions.isTransformationRequired(),</span><br><span class="line">        requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">        requestOptions.getOptions(),</span><br><span class="line">        requestOptions.isMemoryCacheable(),</span><br><span class="line">        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">        requestOptions.getUseAnimationPool(),</span><br><span class="line">        requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">        <span class="keyword">this</span>);<span class="comment">//关键代码</span></span><br><span class="line">  &#125;     </span><br><span class="line">      </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过get方法获取Bitmap</span></span><br><span class="line">    Object received = resource.get();</span><br><span class="line">		...</span><br><span class="line">    onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			...</span><br><span class="line">      <span class="keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">        Transition&lt;? <span class="keyword">super</span> R&gt; animation =</span><br><span class="line">            animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">        <span class="comment">//核心代码</span></span><br><span class="line">        target.onResourceReady(result, animation);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>SingleRequest的onResourceReady(...)方法最后调用了target.onResourceReady(result, animation);这个target就是我们在最开始调用Glide.into(imageview)时Imageview的包装类BitmapImageViewTarget。但是在BitmapImageViewTarget这个类里并没有onResourceReady()方法，因为BitmapImageViewTarget继承了ImageViewTarget，我们在ImageViewTarget中找到了这个重写的onResourceReady()方法。 
</code></pre>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Z</span>&gt; <span class="keyword">extends</span> <span class="title">ViewTarget</span>&lt;<span class="title">ImageView</span>, <span class="title">Z</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Transition</span>.<span class="title">ViewAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(@NonNull Z resource, @Nullable Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="comment">// 核心代码</span></span><br><span class="line">        setResourceInternal(resource);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maybeUpdateAnimatable(resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(@Nullable Z resource)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Order matters here. Set the resource first to make sure that the Drawable has a valid and</span></span><br><span class="line">      <span class="comment">// non-null Callback before starting it.</span></span><br><span class="line">      <span class="comment">//这里调用了抽象方法setResource。</span></span><br><span class="line">      setResource(resource);</span><br><span class="line">      maybeUpdateAnimatable(resource);</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(@Nullable Z resource)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>**BitmapImageViewTarget重写了setResource(@Nullable Z resource)方法**
</code></pre>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> com.bumptech.glide.request.target.Target&#125; that can display an &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * android.graphics.Bitmap&#125; in an &#123;<span class="doctag">@link</span> android.widget.ImageView&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapImageViewTarget</span> <span class="keyword">extends</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the &#123;<span class="doctag">@link</span> android.graphics.Bitmap&#125; on the view using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resource The bitmap to display.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(Bitmap resource)</span> </span>&#123;</span><br><span class="line">    view.setImageBitmap(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   至此，通过 view.setImageBitmap(resource)将Bitmap设置到了Imageview上，图片也就显示出来了。可见into()方法是极其复杂的。Glide整个主线流程到此分析结束。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/深度剖析Android-10大开源框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/深度剖析Android-10大开源框架/" itemprop="url">深度剖析Android 10大开源框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-05T10:09:26+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>第一章：介绍</strong></p>
<p>流程，原理，机制，核心类源码剖析</p>
<ol>
<li>网络框架：Okhttp / retrofit</li>
<li>依赖注入：butterknife / dagger2</li>
<li>异步处理：rxjava / eventbus</li>
<li>图片框架:：glide / picasso</li>
<li>性能优化：leakcanary / blockcanary</li>
</ol>
<p><strong>第二章：okhttp</strong></p>
<ol>
<li><p>OkHttpClient 和 Request 都可以通过Builder模式创建。OkHttpClient可以通过buil模式设置请求的</p>
</li>
<li><p>client.dispatcher().enqueue(new AsyncCall(responseCallback));</p>
</li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp1.png" alt="okhttp1" style="zoom:30%;"></p>
<p>3.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp2.png" alt="okhttp1" style="zoom:30%;"></p>
<ol start="4">
<li>问题1：okhttp 如何实现同步异步请求？</li>
</ol>
<p>​    答：发送同步  / 异步请求都会在dispatcher 中管理其状态。</p>
<ol start="5">
<li>问题2：到底什么是dispatcher?</li>
</ol>
<p>​    答：dispatcher 的作用为维护请求的状态，并维护一个线程池，用于执行请求。</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp3.png" alt="okhttp1" style="zoom:30%;"></p>
<p>6.问题3：异步请求为什么需要两个队列？</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp4.png" alt="okhttp1" style="zoom:30%;"></p>
<ol start="7">
<li>Okhttp 的任务调度</li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp5.png" alt="okhttp1" style="zoom:30%;"></p>
<p>​       答：会在一个请求结束后，调用 Dispatcher 里的finish方法时，finish方法里又调用了promoteCalls()，这里会把readyAsycCalls里等待的请求添加到runningAsyncCalls，并且通过线程池executorService().execute(call)执行这个请求。</p>
<ol start="8">
<li><p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp6.png" alt="okhttp1" style="zoom:30%;"></p>
</li>
<li><p>Okhttp 拦截器</p>
</li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp7.png" alt="okhttp1" style="zoom:30%;"></p>
<ol start="10">
<li><p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp8.png" alt="okhttp1" style="zoom:30%;"></p>
</li>
<li></li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp9.png" alt="okhttp1" style="zoom:30%;"></p>
<ol start="12">
<li>getResponseWithInterceptorChain()</li>
</ol>
<p>这个方法所做的就是构成了一个拦截器的链，然后通过依次执行每一个不同功能的拦截器，来获取我们服务器的响应返回。</p>
<p>13.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp10.png" alt="okhttp1" style="zoom:30%;"></p>
<p>14.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp11.png" alt="okhttp1" style="zoom:30%;"></p>
<p>15.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp12.png" alt="okhttp1" style="zoom:30%;"></p>
<p>16.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp13.png" alt="okhttp1" style="zoom:30%;"></p>
<ol start="17">
<li><p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp14.png" alt="okhttp1" style="zoom:30%;"></p>
</li>
</ol>
<p>18.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp15.png" alt="okhttp1" style="zoom:30%;"></p>
<p>okhttp会将客户端和服务端的连接抽象成一个Connection接口类，它的实现类就是RealConnection。</p>
<ol start="19">
<li>ConnectionPool</li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp16.png" alt="okhttp1" style="zoom:30%;"></p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp17.png" alt="okhttp1" style="zoom:30%;"></p>
<p>20.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp18.png" alt="okhttp1" style="zoom:30%;"></p>
<ol start="21">
<li>CallServerInterception </li>
</ol>
<p>这里面几个重点类：</p>
<ul>
<li>RealInterception:okhttp拦截器中的一个链，所有的网络请求正式通过这个链，链接到一起完成相应的功能。正是proceed方法能让依次进行下一个链的操作。</li>
<li><p>Httpcodec：okhttp中将所有的流对象都封装成了Httpcodec这个类，这是一个接口，CallServerInterceptor这个拦截器正是通过Httpcodec里的Socket流来完成操作的 。简单讲就是Httpcodec将request编码，将response解码。HttpCodec是对 HTTP 协议操作的抽象，有两个实现：Http1Codec和Http2Codec，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。在这个方法的内部实现连接池的复用处理</p>
</li>
<li><p>StreamAllocation：它是用来建立okhttp请求所需要的其他的网络设施的组件，它的作用是用来分配Stream。它相当于一个管理类，维护了服务器连接、并发流。</p>
</li>
<li>RealConnection:okhttp会将客户端和服务端的连接抽象成一个Connection连接，而这个抽象连接的具体实现就是RealConnection。</li>
<li>Request: 代表网络请求。</li>
</ul>
<p>22.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp19.png" alt="okhttp1" style="zoom:30%;"></p>
<p>拦截器链里的拦截器</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp20.png" alt="okhttp1" style="zoom:30%;"></p>
<ul>
<li>RetryAndFollowUpInterceptor ：主要是重试和重定向我们的请求。</li>
<li>CacheInterceptor：处理缓存。负责读取缓存直接返回、更新缓存。</li>
<li>BridgeInterceptor：负责okhttp请求和响应对象与实际的http协议中请求和响应的转换。转换过程中可以处理一些cookie相关的内容。比如请求时，对必要的Header进行一些添加，接收响应时，移除必要的Header。</li>
<li>ConnectInterceptor： 负责和服务器建立连接。</li>
<li>CallServerInterceptor：负责完成最终的网络请求。负责发送请求和响应两大工作。负责向服务器发送请求数据、从服务器读取响应数据。</li>
</ul>
<p>23.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp21.png" alt="okhttp1" style="zoom:30%;"></p>
<p>24.</p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/okhttp22.png" alt="okhttp1" style="zoom:30%;"></p>
<p><strong>第三章：Retrofit</strong></p>
<ol>
<li></li>
</ol>
<ul>
<li>App应用程序通过Retrofit请求网络，实际上是使用Retrofit接口层封装请求参数，之后由OkHttp完成后续的请求操作。</li>
<li>在服务端返回数据之后，OkHttp 将原始的结果交给Retrofit,Retrofit根据用户的需求对结果进行解析。</li>
</ul>
<ol start="2">
<li></li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/retrofit1.png" alt="retrofit1" style="zoom:30%;"></p>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/retrofit2.png" alt="retrofit1" style="zoom:30%;"></p>
<p>Retrofit 将每一个Http请求抽象成了java 接口，然后用注解配置请求的参数。内部实现原理就是用动态代理将接口的注解翻译成一个一个的请求，再有我们的线程池来执行请求。</p>
<ol start="3">
<li><p><strong>动态代理</strong>：代理类在程序运行时创建的代理方式。不用频繁的修改每一个代理类的函数。</p>
</li>
<li></li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/retrofit3.png" alt="retrofit1" style="zoom:30%;"></p>
<ol start="5">
<li></li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/retrofit4.png" alt="retrofit1" style="zoom:30%;"></p>
<ol start="6">
<li>涉及到的设计模式：</li>
</ol>
<ul>
<li>工厂设计模式：将类实例化的操作与使用对象的操作相分开，这样客户端使用的时候不需要知道具体参数，就可以通过Factory提供给我们的静态方法，来创建我们需要的产品。</li>
<li>抽象工厂模式：CallAdapter</li>
<li>简单工厂模式：Platform 获取平台</li>
<li>外观模式：屏蔽了Retrofit内部细节，使用者只关注Retrofit，通过Retrofit设置参数就行了。</li>
<li>策略模式：工厂模式强调的是生产不同的对象。策略模式是这些不同对象的策略方法具体实现。 </li>
<li>适配器模式：将OkHttpCall适配成不同平台（Android、Java8、ios、Rxjava）的Call。</li>
<li>观察者模式：Call是被观察者，OkHttpCall实现了Call，是实际的被观察者。Callback是被观察者。  </li>
</ul>
<ol start="7">
<li></li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/retrofit5.png" alt="retrofit1" style="zoom:30%;"></p>
<ol start="8">
<li></li>
</ol>
<p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/retrofit6.png" alt="retrofit1" style="zoom:30%;"></p>
<ol start="9">
<li><p><img src="/Users/yuxibing/Work_codes/MyBlog/WarriorYu.github.io/source/images/retrofit7.png" alt="retrofit1" style="zoom:30%;"></p>
</li>
</ol>
<blockquote>
<p>BAT大牛带你深度剖析Android 10大开源框架</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/ButtterKnife和AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/ButtterKnife和AOP/" itemprop="url">ButtterKnife和AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-05T09:55:50+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>ButtterKnife 的工作原理</p>
<ul>
<li>编译的时候扫描注解，并做相应处理，生成java代码，生成 java 代码是调用 javapoet 库生成的。</li>
<li>调用 ButterKnife.bing(this)；方法的时候，将 ID 与对应的上下文绑定在一起。</li>
</ul>
</li>
<li><p>AOP 插桩工具 AspectJ、ASM、ReDex</p>
<p>练习了AspectJ的使用</p>
<p>参考：</p>
<p><a href="https://time.geekbang.org/column/article/82761?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noopener">Android开发高手课：27 | 编译插桩的三种方法：AspectJ、ASM、ReDex</a></p>
<p><a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之AOP</a></p>
<p><a href="https://blog.csdn.net/yxhuang2008/article/details/94193201" target="_blank" rel="noopener">AspectJ 在 Android 中的使用</a></p>
<p><a href="https://github.com/raphw/byte-buddy" target="_blank" rel="noopener">https://github.com/raphw/byte-buddy</a></p>
<p><a href="https://github.com/HujiangTechnology" target="_blank" rel="noopener">HujiangTechnology</a>/<a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">gradle_plugin_android_aspectjx</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/geenDao-源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/05/geenDao-源码分析/" itemprop="url">geenDao 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-05T16:39:42+08:00">
                2020-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="greenDao-源码分析"><a href="#greenDao-源码分析" class="headerlink" title="greenDao 源码分析"></a>greenDao 源码分析</h1><p><img src="/images/greenDAO-orm.png" alt="Introduction"></p>
<h3 id="一-核心类"><a href="#一-核心类" class="headerlink" title="一. 核心类"></a>一. 核心类</h3><h4 id="1-DaoMaster"><a href="#1-DaoMaster" class="headerlink" title="1. DaoMaster"></a>1. DaoMaster</h4><ul>
<li><p>DaoMaster是使用greenDao的入口。</p>
</li>
<li><p>DaoMaster持有数据库对象，并且管理特定表的Dao类（而非对象）。</p>
</li>
<li><p>它具有创建表或者删除表的静态方法。</p>
</li>
<li><p>其内部类 OpenHelper 和 DevOpenHelper 是 SQLiteOpenHelper 的实现，<br>可在 SQLite 数据库中创建表 。</p>
</li>
</ul>
<h4 id="2-DaoSession"><a href="#2-DaoSession" class="headerlink" title="2. DaoSession"></a>2. DaoSession</h4><ul>
<li><p>DaoSession 管理特定表的所有可用DAO对象，这些对象可以通过相应的get方法获取。</p>
</li>
<li><p>DaoSession 还为实体提供了一些通用的方法，例如插入、加载、更新、刷新和删除。</p>
</li>
<li><p>DaoSession 还可以管理缓存。</p>
</li>
</ul>
<h4 id="3-XXXDao"><a href="#3-XXXDao" class="headerlink" title="3. XXXDao"></a>3. XXXDao</h4><ul>
<li><p>XXXDao 是数据访问对象，可以持久化和查询实体。</p>
</li>
<li><p>对于每一个实体，greeDao 会自动生成一个 DAO。</p>
</li>
<li><p>它比 DaoSession 具有更多的持久化方法，例如count, loadAll, insertInTx。</p>
</li>
</ul>
<h4 id="4-Entities"><a href="#4-Entities" class="headerlink" title="4. Entities"></a>4. Entities</h4><ul>
<li><p>实体，即持久化的对象。通常，实体是使用标准 Java属性（例如 POJO 或 JavaBean ）表示数据库行的对象。  </p>
</li>
<li><p>注意：只支持 Java class，如果你使用 Kotlin ，实体类仍然要使用 Java class 。</p>
</li>
<li><p>Entity注解里可配置的属性  </p>
<p>@Entity(</p>
<pre><code>// If you have more than one schema, you can tell greenDAO
// to which schema an entity belongs (pick any string as a name).
schema = &quot;myschema&quot;,
</code></pre></li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Flag to make an entity "active": Active entities have update,</span></span><br><span class="line">    <span class="comment">// delete, and refresh methods.</span></span><br><span class="line">    active = <span class="keyword">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Specifies the name of the table in the database.</span></span><br><span class="line">    <span class="comment">// By default, the name is based on the entities class name.</span></span><br><span class="line">    nameInDb = <span class="string">"AWESOME_USERS"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Define indexes spanning multiple columns here.</span></span><br><span class="line">    indexes = &#123;</span><br><span class="line">            <span class="meta">@Index</span>(value = <span class="string">"name DESC"</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Flag if the DAO should create the database table (default is true).</span></span><br><span class="line">    <span class="comment">// Set this to false, if you have multiple entities mapping to one table,</span></span><br><span class="line">    <span class="comment">// or the table creation is done outside of greenDAO.</span></span><br><span class="line">    createInDb = <span class="keyword">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whether an all properties constructor should be generated.</span></span><br><span class="line">    <span class="comment">// A no-args constructor is always required.</span></span><br><span class="line">    generateConstructors = <span class="keyword">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whether getters and setters for properties should be generated if missing.</span></span><br><span class="line">    generateGettersSetters = <span class="keyword">true</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-图示以上几个类的关系"><a href="#5-图示以上几个类的关系" class="headerlink" title="5. 图示以上几个类的关系"></a>5. 图示以上几个类的关系</h4><p><img src="/images/Core-Classes-150.png" alt="Core Classes"></p>
<h3 id="二-源码分析"><a href="#二-源码分析" class="headerlink" title="二. 源码分析"></a>二. 源码分析</h3><h4 id="1-结构图"><a href="#1-结构图" class="headerlink" title="1. 结构图"></a>1. 结构图</h4><p><img src="/images/greeDao结构图.png" alt="greenDao整体结构图"> </p>
<p>​                                                 图片来源于：<a href="https://blog.csdn.net/kieCool/article/details/73930813" target="_blank" rel="noopener">https://blog.csdn.net/kieCool/article/details/73930813</a></p>
<h4 id="2-参考："><a href="#2-参考：" class="headerlink" title="2. 参考："></a>2. 参考：</h4><blockquote>
<ol>
<li><a href="https://greenrobot.org/greendao/" target="_blank" rel="noopener">官网</a> </li>
<li><a href="https://www.jianshu.com/u/6e5ebce41b4f" target="_blank" rel="noopener">嘎啦果安卓兽</a>：<a href="https://www.jianshu.com/p/10b04b86c29a" target="_blank" rel="noopener">GreenDAO源码整体流程梳理</a></li>
<li>上面的时序图可配合这个文章查看：<a href="https://juejin.im/post/5d3a9193e51d4510a37bacd8" target="_blank" rel="noopener">https://juejin.im/post/5d3a9193e51d4510a37bacd8</a></li>
<li><a href="https://juejin.im/post/5e44b3c2e51d4526ec0d2b71" target="_blank" rel="noopener">jsonchao</a></li>
</ol>
</blockquote>
<h3 id="三-需要注意的几个点"><a href="#三-需要注意的几个点" class="headerlink" title="三. 需要注意的几个点"></a>三. 需要注意的几个点</h3><h4 id="1-数据库更新："><a href="#1-数据库更新：" class="headerlink" title="1. 数据库更新："></a>1. 数据库更新：</h4><ul>
<li><p>为简单起见，使用由生成的DaoMaster类提供的帮助器类DevOpenHelper创建数据库。 它是DaoMaster中OpenHelper类的实现，它为您完成了所有数据库的设置。 无需编写“ CREATE TABLE”语句。</p>
<p>但是，DevOpenHelper在数据库更新时会删除所有表（在onUpgrade（）中）。 因此，建议您创建并使用DaoMaster.OpenHelper的子类。 </p>
<p>然后，Activities and fragments 可以调用getDaoSession（）来访问所有实体DAO。 </p>
</li>
<li><p><a href="https://github.com/yuweiguocn/GreenDaoUpgradeHelper" target="_blank" rel="noopener">GreenDaoUpgradeHelper</a> 是一个greenDao的数据库升级帮助类。使用它可以很容易解决数据库升级问题，只需一行代码。原始代码来自<a href="http://stackoverflow.com/a/30334668/7161403" target="_blank" rel="noopener">stackoverflow</a>。 </p>
</li>
</ul>
<h4 id="2-主键限制："><a href="#2-主键限制：" class="headerlink" title="2. 主键限制："></a>2. 主键限制：</h4><p>实体类必须有一个long/Long类型的主键。对于这种情况，可将你的关键属性定义为附加属性，但是要为其创建唯一索引。 </p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Index</span>(unique = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">private</span> String key;</span><br></pre></td></tr></table></figure>
<h4 id="3-多对多"><a href="#3-多对多" class="headerlink" title="3. 多对多"></a>3. <a href="https://greenrobot.org/greendao/documentation/relations/" target="_blank" rel="noopener">多对多</a></h4><ul>
<li><p>对于多对多的实体，因为第一次获取的时候会缓存，所以再次获取的不是新数据，如果更新了数据，需要手动更新获取的数据，防止使用缓存。</p>
</li>
<li><p>或者先清除缓存，再获取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clear any cached list of related orders</span></span><br><span class="line">customer.resetOrders();</span><br><span class="line">List&lt;Order&gt; orders = customer.getOrders();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-Convert-annotation-and-property-converter"><a href="#4-Convert-annotation-and-property-converter" class="headerlink" title="4. Convert annotation and property converter"></a>4. Convert annotation and property converter</h4><ul>
<li>注意：如果在实体类中定义自定义Type或者converter，要使用static修饰他们。 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/29/Android-Handler消息机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/29/Android-Handler消息机制/" itemprop="url">Android - Handler消息机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-29T19:58:16+08:00">
                2020-02-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-Handler-消息机制"><a href="#Android-Handler-消息机制" class="headerlink" title="Android - Handler 消息机制"></a>Android - Handler 消息机制</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h2><h3 id="1-Handler"><a href="#1-Handler" class="headerlink" title="1. Handler"></a>1. Handler</h3><p><strong>个人理解</strong>：</p>
<ul>
<li>消息辅助类，Handler 是主线程和子线程沟通的桥梁，可以通过以 send / post 为前缀的一些方法（例如:sendMessage、postDelayed）发送消息（Message）到消息队列（MessageQueue）；也可以处理消息循环器（Looper）分发过来的消息（Message），轻松的将一个任务切换到 Handler 所在的线程中执行。Android不允许在子线程中更新UI，在子线程执行耗时操作后，通过Handler将更新UI的操作切换到主线程执行。</li>
</ul>
<p><strong>Google官方文档的介绍（我的蹩脚翻译）：</strong></p>
<ul>
<li>通过 Handler 可以发送和处理 Message / Runnable 对象，Message 和 Runnable 跟线程的<a href="https://developer.android.google.cn/reference/android/os/MessageQueue" target="_blank" rel="noopener">MessageQueue</a> 相关。每个 Handler 实例都关联一个线程（Thread）和该线程的消息队列（MessageQueue）。创建Handler的同时会绑定到 <a href="https://developer.android.google.cn/reference/android/os/Looper" target="_blank" rel="noopener">Looper</a>  。Looper 可以在 MessageQueue 里 添加 /取出 Message / Runnable ，并且 Looper 是运行在创建Handler的线程中。</li>
<li>Handler 有两个主要的用途：<ol>
<li>使 Message / Runnable 在未来的某个时间点得到处理。</li>
<li>处理不同线程的队列消息  </li>
</ol>
</li>
<li>Handler可以通过<code>post(Runnable)</code>, <code>postAtTime(java.lang.Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, and <code>sendMessageDelayed(Message, long)</code>发送消息。以 post 版本的方法是将 Runnable 对象封装成Message添加到消息队列，当Handler接收到消息时，会回调Runnable的run()方法;sendMessage 版本的方法将携带一些信息的Message对象添加到消息队列，当接收消息时，会回调handleMessage(Message)方法，这个方法在你创建Handler的时候由自己来重写。</li>
</ul>
<h3 id="2-Message"><a href="#2-Message" class="headerlink" title="2. Message"></a>2. Message</h3><p><strong>个人理解：</strong></p>
<ul>
<li>存储通信数据信息，是Handler发送、处理的消息对象。用于在主线程和子线程中传递。在子线程中将各种需要更新到UI的数据信息封装到Message中，然后通过Handle在主线程中解析出Message的信息，更新到UI。</li>
</ul>
<p><strong>Google官方文档的介绍（我的翻译）：</strong></p>
<ul>
<li><p>Message 可用于发送给 Handler ，它包含三种int类型（what、arg1、arg2）和一个对象（obj）字段，不需要你自己再添加配置字段。</p>
<p>☆  虽然 Message 的构造方法是 public 的,但是最高效的方式是通过调用 Message.obtain() 或者            Handler#obtainMessage 方法获得 Message 对象, 这种方式是通过对象池来获取 Message 。</p>
</li>
</ul>
<h3 id="3-MessageQueue"><a href="#3-MessageQueue" class="headerlink" title="3. MessageQueue"></a>3. MessageQueue</h3><p><strong>个人理解：</strong></p>
<ul>
<li>消息队列, 消息队列的主要功能是向消息池发送消息(<code>MessageQueue.enqueueMessage()</code>)和取走消息池的消息(<code>MessageQueue.next()</code>)；尽管MessageQueue叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构（即Message）来维护消息列表，单链表在插入和删除上比较有优势。   </li>
</ul>
<p><strong>Google官方文档的介绍（我的翻译）：</strong></p>
<ul>
<li>一个简单的类，持有 Looper 分发的消息列表。Message 不是直接添加到 MessageQueue 中，而是通过跟Looper相关的Handler对象。</li>
<li>可以通过 Looper.myQueue() 获取当前线程的MessageQueue。</li>
</ul>
<h3 id="4-Looper"><a href="#4-Looper" class="headerlink" title="4. Looper :"></a>4. Looper :</h3><p><strong>个人理解：</strong></p>
<ul>
<li>消息循环器，通过 Looper.loop() 负责在消息队列（MessageQueue）循环取出消息（Message），并且分发给对应的处理者（Handler）。是消息队列（MessageQueue）与处理者（Handler）的通信媒介。每个线程只能拥有一个 Looper  ；一个 Looper 可以绑定多个线程的 Handler；所以多个线程通过Handler 发送 Message 时，是往同1个 Looper 所持有的 MessageQueue 中发送消息，提供了线程间通信的可能。</li>
</ul>
<p><strong>Google 官方文档的介绍（我的翻译）：</strong></p>
<ul>
<li><p>Looper这个类用于在线程中进行消息循环。默认创建的子线程没有 Looper，如果创建的话，在线程中调用 prepare() ，然后调用 loop() 开启消息循环。</p>
</li>
<li><p>大部分与消息循环器（Looper）的交互是通过 Handler 类。</p>
</li>
<li><p>下面是一个 Looper/Thread 的典型例子，通过 prepare() 和 loop() ，创建 Handler 和Looper交互。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-源码解读："><a href="#二-源码解读：" class="headerlink" title="二.  源码解读："></a>二.  源码解读：</h2><h3 id="从一个普通的例子说起："><a href="#从一个普通的例子说起：" class="headerlink" title="从一个普通的例子说起："></a>从一个普通的例子说起：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在主线程以匿名内部类的方式创建Handler对象</span></span><br><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//更新UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2.创建消息对象</span></span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//3.在子线程中通过Handler发送消息到消息队列中</span></span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="分析1："><a href="#分析1：" class="headerlink" title="分析1："></a>分析1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handler的无参构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//待分析：1</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析：1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 匿名类、内部类、本地类都必须声明为static,</span></span><br><span class="line">    <span class="comment">//否则就会出现我们常看到的黄色代码块的警告，</span></span><br><span class="line">  	<span class="comment">//提示可能会出现内存泄漏。</span></span><br><span class="line">  	<span class="comment">//async默认是false，即创建Handler时，决定了以后创建的普通消息就是同步消息</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || 							klass.isLocalClass())&amp;&amp;</span><br><span class="line">             (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1.2 在ThreadLocal中获取当前线程的Looper对象，如果没有Looper则无法创建Handler</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.3 消息队列，来自Looper对象</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;<span class="comment">//回调方法</span></span><br><span class="line">    mAsynchronous = async;<span class="comment">//设置消息是否为异步处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题：上述1-2-的Looper对象是怎么来的呢？"><a href="#问题：上述1-2-的Looper对象是怎么来的呢？" class="headerlink" title="问题：上述1.2 的Looper对象是怎么来的呢？"></a><strong>问题：上述1.2 的Looper对象是怎么来的呢？</strong></h3><h4 id="答：分两种情况："><a href="#答：分两种情况：" class="headerlink" title="答：分两种情况："></a><strong>答：分两种情况：</strong></h4><ol>
<li><p><strong>如果在主线程中创建Handler。</strong>在 Android 应用进程启动时，会默认创建 1 个主线程 ActivityThread（Android的主线程就是 ActivityThread ，也叫UI线程），主线程的入口方法为 main() ，在 main() 方法中系统会通过 Looper.prepareMainLooper() 来创建主线程的 Looper 以及 MessageQueue ，并通过 Looper.loop() 来开启主线程的消息循环。这个过程就是上面代码所示。</p>
</li>
<li><p><strong>如果在子线程中创建Handler。</strong>则必须为当前线程创建 Looper，所以需要手动调用Looper.prepare() 创建Looper，然后调用 loop() 开启消息循环。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...省略部分无关代码...</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue</span></span><br><span class="line">       <span class="comment">//待分析：2</span></span><br><span class="line">       Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...省略部分无关代码...</span></span><br><span class="line"></span><br><span class="line">       ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">       thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...省略部分无关代码...</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//待分析：3</span></span><br><span class="line">       <span class="comment">//通过Looper.loop()来开启主线程的消息循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析2、分析3："><a href="#分析2、分析3：" class="headerlink" title="分析2、分析3："></a>分析2、分析3：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Looper这个类用于在线程中进行消息循环。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建Looper的同时，创建了MessageQueue，并且绑定了当前线程</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">       mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">       mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**分析：2</span></span><br><span class="line"><span class="comment">    * 初始化当前线程的Looper，并且标记为应用程序的主线程Looper。</span></span><br><span class="line"><span class="comment">    * 应用程序的主线程Looper是Android环境自动创建的，所以</span></span><br><span class="line"><span class="comment">    * 不需要你自己去调用这些方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       prepare(<span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">           <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//主线程的Looper</span></span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 默认手动创建的子线程没有Looper，如果创建的话，在子线程中调用prepare()，</span></span><br><span class="line"><span class="comment">    * 然后调用 loop() 开启消息循环。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//在这里也可以看出每个线程只能有 1 个Looper</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//在这里创建了Looper，在上面Looper的构造方法里可以看出，创建Looper的同时，</span></span><br><span class="line">     <span class="comment">//创建了MessageQueue，并且绑定了当前线程</span></span><br><span class="line">     sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**分析：3</span></span><br><span class="line"><span class="comment">    * 在当前线程执行消息循环。在消息循环结束后要调用 quit() 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取ThreadLocal存储的Looper对象</span></span><br><span class="line">       <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//在调用loop()之前必须通过Looper.prepare()获取Looper对象</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取Looper对象中的消息队列</span></span><br><span class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//进入loop的消息循环</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">//取出消息队列里的消息，这里会导致阻塞</span></span><br><span class="line">           <span class="comment">//待分析：4</span></span><br><span class="line">           Message msg = queue.next();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//通过Message的target（target是Handler对象）进行消息的派发,</span></span><br><span class="line">           <span class="comment">//即回调Hander.dispatchMessage(msg)</span></span><br><span class="line">           <span class="comment">//待分析：5</span></span><br><span class="line">           msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//回收Message，放入消息池。</span></span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析4："><a href="#分析4：" class="headerlink" title="分析4："></a>分析4：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;  </span><br><span class="line">  <span class="comment">/**分析：4</span></span><br><span class="line"><span class="comment">    * 在消息队列中取出下一条消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">   <span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在第一次循环迭代时为-1</span></span><br><span class="line">   <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//...省略部分无关代码</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//这是native的方法。nativePollOnce是阻塞操作，</span></span><br><span class="line">       <span class="comment">//其中nextPollTimeoutMillis代表下一个消息到来前，</span></span><br><span class="line">       <span class="comment">//还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</span></span><br><span class="line">       <span class="comment">//当nextPollTimeoutMillis时长已经消耗完，或者消息队列被唤醒，都会返回。</span></span><br><span class="line">       nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">           android.os.Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">           android.os.Message msg = mMessages;</span><br><span class="line">            <span class="comment">//当消息的Handler为空时，则查询异步消息</span></span><br><span class="line">           <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//当查询到异步消息，则立刻退出循环</span></span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   prevMsg = msg;</span><br><span class="line">                   msg = msg.next;</span><br><span class="line">               &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//当异步消息的触发时间大于当前时间，则设置下一次轮循的超时时长。</span></span><br><span class="line">                   <span class="comment">//在下次循环时nativePollOnce(ptr, nextPollTimeoutMillis)执行等待这个时长。</span></span><br><span class="line">                   <span class="comment">//源码的注释是这样说的：下一个消息还没有就绪。设置一个唤醒该消息的超时时间。</span></span><br><span class="line">                   nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, 			 	 		     																							Integer.MAX_VALUE);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 获取一条消息，并返回给Looper.loop()的for循环里</span></span><br><span class="line">                   mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       prevMsg.next = msg.next;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       mMessages = msg.next;</span><br><span class="line">                   &#125;</span><br><span class="line">                   msg.next = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                   <span class="comment">//设置消息的使用状态</span></span><br><span class="line">                   msg.markInUse(); <span class="comment">// void markInUse() &#123; flags |= FLAG_IN_USE; &#125;</span></span><br><span class="line">                   <span class="keyword">return</span> msg; <span class="comment">// 返回MessageQueue中的下一条即将执行的消息</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 没有消息则返回-1</span></span><br><span class="line">               nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所有挂起的消息已经处理完毕，消息正在退出，返回null</span></span><br><span class="line">           <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">               dispose();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//当消息队列为空，或者消息队列里即将处理的消息是是第一条时。</span></span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; 																	mMessages.when)) &#123;</span><br><span class="line">               pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//没有dle handlers需要运行。则循环并等待</span></span><br><span class="line">               mBlocked = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, 									<span class="number">4</span>)];</span><br><span class="line">           &#125;</span><br><span class="line">           mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//只在第一次迭代循环时会进入下面的代码来运行idle handlers 。</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">           mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               keep = idler.queueIdle();<span class="comment">//idle时执行的方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   mIdleHandlers.remove(idler);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//重置idle handler个数为0，以保证不会再次重复运行</span></span><br><span class="line">       pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当调用一个空闲handler时，一个新message能够被分发，</span></span><br><span class="line">       <span class="comment">//因此无需等待可以直接查询pending message.</span></span><br><span class="line">       nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析5-："><a href="#分析5-：" class="headerlink" title="分析5 ："></a>分析5 ：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**分析：5</span></span><br><span class="line"><span class="comment">    * 根据传入的消息方式，来决定处理消息的回调方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 优先级1： 若msg.callback属性不为空，则代表使用了post（Runnable r）发送消息</span></span><br><span class="line">       <span class="comment">// 则执行handleCallback(msg)，即回调Runnable对象里复写的run（）</span></span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">           handleCallback(msg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//优先级2：如果mCallback！=null，则执行</span></span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//优先级3：执行创建Handler时重写的handleMessage(msg)方法</span></span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">       message.callback.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="至此，消息循环、分发的过程分析完毕，总结一下："><a href="#至此，消息循环、分发的过程分析完毕，总结一下：" class="headerlink" title="至此，消息循环、分发的过程分析完毕，总结一下："></a><strong>至此，消息循环、分发的过程分析完毕，总结一下：</strong></h3><ol>
<li><p>通过 Looper.loop() 里的 for 循环来不断轮询消息；</p>
</li>
<li><p>通过 for 循环里的 MessageQueue.next() 方法获取下一条要处理的消息；</p>
</li>
<li><p>MessageQueue 的 next() 方法去获取消息队列里的消息；  </p>
<ul>
<li><p>成功获取到一条消息，则通过Message的target属性（即Handler）调用dispatchMessage(msg)方法处理消息，在该方法里又有三种不同的消息处理回调方式（代码里可以看出是有3种优先级顺序的），回调方式因创建Handler和发送消息方式的不同而不同。</p>
</li>
<li><p>如果消息的触发时间大于当前时间，则在next()方法里阻塞，阻塞时间根据创建消息时设定的延迟时间决定；这里涉及到native的方法，有利于节省CPU的资源。</p>
</li>
</ul>
</li>
</ol>
<h3 id="下一步，我们继续分析消息的发送、入队过程："><a href="#下一步，我们继续分析消息的发送、入队过程：" class="headerlink" title="下一步，我们继续分析消息的发送、入队过程："></a><strong>下一步，我们继续分析消息的发送、入队过程：</strong></h3><h5 id="在子线程中通过Handler发送消息到消息队列中"><a href="#在子线程中通过Handler发送消息到消息队列中" class="headerlink" title="在子线程中通过Handler发送消息到消息队列中 :"></a><strong>在子线程中通过Handler发送消息到消息队列中 :</strong></h5><ul>
<li>send/post 发送消息的各种方法，最终都是调用 MessageQueue.enqueueMessage()方法</li>
</ul>
<h4 id="send方法："><a href="#send方法：" class="headerlink" title="send方法："></a><strong>send方法：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将消息发送到消息队列</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          delayMillis = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//获取对应的消息队列对象</span></span><br><span class="line">      MessageQueue queue = mQueue;</span><br><span class="line">      <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">          RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                  <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">          Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">      Message msg = Message.obtain();</span><br><span class="line">      msg.what = what;</span><br><span class="line">      <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取对应的消息队列对象</span></span><br><span class="line">      MessageQueue queue = mQueue;</span><br><span class="line">      <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">          RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">              <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">          Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//将当前的Handler对象赋值给msg.target；</span></span><br><span class="line">    	<span class="comment">//这里可以和Looper.loop()的for循环里的msg.target.dispatchMessage(msg)联系起来理解；</span></span><br><span class="line">    	<span class="comment">//target就是在这里被赋值的。</span></span><br><span class="line">      msg.target = <span class="keyword">this</span>;</span><br><span class="line">      msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">      <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">          msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">//调用消息队列的enqueueMessage()，将消息加入消息队列</span></span><br><span class="line">      <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="post方法："><a href="#post方法：" class="headerlink" title="post方法："></a><strong>post方法：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(@NonNull Runnable r, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(@NonNull Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以看出，post方式是通过将Runnable赋值给Message的callback属性，封装成Message，</span></span><br><span class="line">    <span class="comment">//归根到底和send方式一样，都是发送的Message消息。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line">       Message m = Message.obtain();</span><br><span class="line">       m.obj = token;</span><br><span class="line">       m.callback = r;</span><br><span class="line">       <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开始分析-MessageQueue-enqueueMessage-方法"><a href="#开始分析-MessageQueue-enqueueMessage-方法" class="headerlink" title="开始分析 MessageQueue.enqueueMessage() 方法"></a>开始分析 MessageQueue.enqueueMessage() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(android.os.Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Message必须有一个target（即Handler）</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            <span class="comment">//如果是正在退出时，回收msg，加入到消息池。recycle()方法我们在下面会分析。</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        android.os.Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//p == null 即消息队列里没有消息，或者msg的触发时间是队列中最早的，则将当前消息作为队头插入；</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            <span class="comment">//如果此时消息队列的循环处于阻塞状态，则唤醒</span></span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，						</span></span><br><span class="line">          	<span class="comment">//除非消息队头存在barrier，并且同时Message是队列中最早执行的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            android.os.Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="comment">//1.第一次循环，msg的触发时间比队头的消息还要早，则跳出for循环，直接加到队头。</span></span><br><span class="line">                  	<span class="comment">//2.往后再次循环，如果遍历到队尾（即 p 节点==null），</span></span><br><span class="line">                  	<span class="comment">//或者当前遍历到的 p 节点的触发时间大于msg的触发时间，则跳出for循环</span></span><br><span class="line">                  	<span class="comment">//将此msg添加到p节点之前(即msg.next = p)。</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//如果新加入的消息是异步消息，并且通过上面的if判断可知:如果新消息按照时间顺序排列的话，不</span></span><br><span class="line">              	<span class="comment">//是队头的元素(即比队头的元素触发时间还要晚），则不需要唤醒(即needWake = false)。</span></span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//链表的操作，将msg添加到链表相应的位置。</span></span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="至此，消息入队的过程分析完毕，总结一下："><a href="#至此，消息入队的过程分析完毕，总结一下：" class="headerlink" title="至此，消息入队的过程分析完毕，总结一下："></a>至此，消息入队的过程分析完毕，总结一下：</h3><ul>
<li>Message入队是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</li>
</ul>
<h3 id="下面，我们继续分析创建消息（Message）对象的最佳方式："><a href="#下面，我们继续分析创建消息（Message）对象的最佳方式：" class="headerlink" title="下面，我们继续分析创建消息（Message）对象的最佳方式："></a>下面，我们继续分析创建消息（Message）对象的最佳方式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建消息对象</span></span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在消息池里返回一个Message对象。避免了创建新对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;<span class="comment">//取出一个消息对象</span></span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;<span class="comment">//将取出的消息在链表里断开连接</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清除 in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小减一</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//当消息池为空时，直接新建消息对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="以上获取Message实例的过程总结为："><a href="#以上获取Message实例的过程总结为：" class="headerlink" title="以上获取Message实例的过程总结为："></a>以上获取Message实例的过程总结为：</h3><ul>
<li>如果消息池不是空的，从消息池（链表结构）的头部取走一个Message，并将链表的头部更新为取走消息的next（即下一条Message）。否则新建Message对象。</li>
</ul>
<h3 id="下面分析recycle（即Message的回收）："><a href="#下面分析recycle（即Message的回收）：" class="headerlink" title="下面分析recycle（即Message的回收）："></a>下面分析recycle（即Message的回收）：</h3><ul>
<li>其中在Looper.loop()方法取出一条消息交给Handler处理后，有一个回收Message到消息池的操作，调用的是recycleUnchecked()：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断消息是否正在使用</span></span><br><span class="line">      <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                      + <span class="string">"is still in use."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      recycleUnchecked();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该方法在处理排队的消息时，在MessageQueue 和 Looper内部调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//将消息标示为IN_USE，并清空消息所有的参数。</span></span><br><span class="line">      flags = FLAG_IN_USE;</span><br><span class="line">      what = <span class="number">0</span>;</span><br><span class="line">      arg1 = <span class="number">0</span>;</span><br><span class="line">      arg2 = <span class="number">0</span>;</span><br><span class="line">      obj = <span class="keyword">null</span>;</span><br><span class="line">      replyTo = <span class="keyword">null</span>;</span><br><span class="line">      sendingUid = UID_NONE;</span><br><span class="line">      workSourceUid = UID_NONE;</span><br><span class="line">      when = <span class="number">0</span>;</span><br><span class="line">      target = <span class="keyword">null</span>;</span><br><span class="line">      callback = <span class="keyword">null</span>;</span><br><span class="line">      data = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">      <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        	<span class="comment">//消息池的大小是MAX_POOL_SIZE = 50，当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">          <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">              next = sPool;</span><br><span class="line">              sPool = <span class="keyword">this</span>;<span class="comment">//将消息添加到消息池的头部</span></span><br><span class="line">            	<span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">              sPoolSize++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上总结为：为了提高效率，减少对象频繁的创建和回收过程，提供了一个消息缓存队列。消息池的默认大小是50，当需要回收消息时（比如：分发消息给Handler处理后），将消息的属性参数清空，然后将回收的消息添加到消息池的头部。</p>
<h4 id="至此，Android的消息机制分析完毕，Android的消息机制源码远没有这么简单，以上仅从Java层进行了分析，对于Native层的分析没有涉及到。希望大家一起加油，踏踏实实分析源码的脉络，遇到同样的问题，做到胸有成竹。也欢迎在留言区一起讨论，一起成长！"><a href="#至此，Android的消息机制分析完毕，Android的消息机制源码远没有这么简单，以上仅从Java层进行了分析，对于Native层的分析没有涉及到。希望大家一起加油，踏踏实实分析源码的脉络，遇到同样的问题，做到胸有成竹。也欢迎在留言区一起讨论，一起成长！" class="headerlink" title="至此，Android的消息机制分析完毕，Android的消息机制源码远没有这么简单，以上仅从Java层进行了分析，对于Native层的分析没有涉及到。希望大家一起加油，踏踏实实分析源码的脉络，遇到同样的问题，做到胸有成竹。也欢迎在留言区一起讨论，一起成长！"></a>至此，Android的消息机制分析完毕，Android的消息机制源码远没有这么简单，以上仅从Java层进行了分析，对于Native层的分析没有涉及到。希望大家一起加油，踏踏实实分析源码的脉络，遇到同样的问题，做到胸有成竹。也欢迎在留言区一起讨论，一起成长！</h4><h3 id="如果想及时收到我的文章更新，可关注以下公众号。"><a href="#如果想及时收到我的文章更新，可关注以下公众号。" class="headerlink" title="如果想及时收到我的文章更新，可关注以下公众号。"></a>如果想及时收到我的文章更新，可关注以下公众号。</h3><p><img src="/images/我的公众号二维码.png" alt="我的公众号二维码"></p>
<blockquote>
<p>参考资料：</p>
<p>1.<a href="https://developer.android.google.cn/reference/android/os/Handler?hl=en" target="_blank" rel="noopener">https://developer.android.google.cn/reference/android/os/Handler?hl=en</a></p>
<p>2.<a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">http://gityuan.com/2015/12/26/handler-message-framework/</a></p>
<p>3 .<a href="https://www.jianshu.com/p/b4d745c7ff7a" target="_blank" rel="noopener">https://www.jianshu.com/p/b4d745c7ff7a</a></p>
<p>4.Android开发艺术探索第十章</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/29/技术人员典型的焦虑和烦恼/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/29/技术人员典型的焦虑和烦恼/" itemprop="url">技术人员典型的焦虑和烦恼</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-29T19:51:51+08:00">
                2020-02-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="技术人员典型的焦虑和烦恼"><a href="#技术人员典型的焦虑和烦恼" class="headerlink" title="技术人员典型的焦虑和烦恼"></a>技术人员典型的焦虑和烦恼</h4><p><img src="/images/google打分卡.jpeg" style="zoom:50%;"> </p>
<p><img src="/images/主动学习.jpeg" style="zoom:50%;"> </p>
<ol>
<li>加班 <ul>
<li>加班时间长，没有时间提升</li>
</ul>
</li>
<li>搬砖<ul>
<li>工作没有技术含量</li>
</ul>
</li>
<li>成长<ul>
<li>成长到了瓶颈期</li>
</ul>
</li>
<li>学习<ul>
<li>东西太多学不过来</li>
</ul>
</li>
<li>彷徨<ul>
<li>失去方向，未来要干什么，要做什么不知道</li>
</ul>
</li>
</ol>
<h5 id="认识一下这个世界"><a href="#认识一下这个世界" class="headerlink" title="认识一下这个世界"></a>认识一下这个世界</h5><ol>
<li><p>这个世界是怎么组成的？</p>
<ul>
<li>基础技术、工具、产品、项目……</li>
<li>大家的分工是怎么来的？</li>
</ul>
</li>
<li><p>这个世界需要什么样的人？以及这些人的特点</p>
<ul>
<li>劳工、技工、特种工、设计、架构、经理……</li>
<li>Google评分卡</li>
</ul>
</li>
<li><p>这个世界的技术趋势和规律是什么样的？</p>
<ul>
<li><p>工业革命、信息化革命</p>
</li>
<li><p>技术更新淘汰、风口是什么样的</p>
<p>历史上发生的，未来一定也会发生，现在没发生的，未来可能发生</p>
</li>
</ul>
</li>
</ol>
<h5 id="认识自己"><a href="#认识自己" class="headerlink" title="认识自己"></a>认识自己</h5><ol>
<li><p>自己的喜好  </p>
<ul>
<li>找到自己可以坚持不会放弃的东西</li>
</ul>
</li>
<li><p>自己的特长是什么 </p>
<ul>
<li>找到自己可以干成的事</li>
<li>找到别人会来请教你的事</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>自己有什么</p>
<ul>
<li>找到可以承上启下的东西  </li>
</ul>
</li>
<li><p>自己可以付出什么</p>
<ul>
<li>找到自己的本金来投资，找到可以付出和牺牲的东西</li>
</ul>
</li>
</ol>
<h4 id="第二部分-夯实基础，一通百通"><a href="#第二部分-夯实基础，一通百通" class="headerlink" title="第二部分 夯实基础，一通百通"></a>第二部分 夯实基础，一通百通</h4><h5 id="为什么要学习基础技术"><a href="#为什么要学习基础技术" class="headerlink" title="为什么要学习基础技术"></a>为什么要学习基础技术</h5><ol>
<li><p>一通百通</p>
<ul>
<li>所有的技术原理和本质都在基础技术上</li>
</ul>
</li>
<li><p>突破瓶颈</p>
<ul>
<li><p>只有基础技术才能让你上升到更高的层次</p>
</li>
<li><p>在技术的世界里，量变永远无法导致质变   </p>
</li>
</ul>
</li>
<li><p>自己推导</p>
<ul>
<li>掌握基础技术以及原理可以让自己推导答案和趋势</li>
</ul>
</li>
</ol>
<h5 id="有哪些基础技术"><a href="#有哪些基础技术" class="headerlink" title="有哪些基础技术"></a>有哪些基础技术</h5><ol>
<li><p>程序语言</p>
<ul>
<li>原理、编程范式、设计模式、代码设计、类库…… </li>
</ul>
</li>
<li><p>系统</p>
<ul>
<li>计算机原理、操作系统、网络协议、数据库……   </li>
</ul>
</li>
<li><p>中间件</p>
<ul>
<li>消息队列、缓存、网关、代理……</li>
</ul>
</li>
<li><p>理论知识</p>
<ul>
<li>算法和数据结构、系统架构、分布式…… </li>
</ul>
</li>
</ol>
<h5 id="如何识别新的技术"><a href="#如何识别新的技术" class="headerlink" title="如何识别新的技术"></a>如何识别新的技术</h5><ol>
<li><p>解决了什么样的问题</p>
<ul>
<li>任何技术的出现都是要解决已知问题的</li>
<li>降低技术门槛、提高开发效率、提升稳定性</li>
</ul>
</li>
<li><p>提升了什么样的能力  </p>
<ul>
<li><p>可以计算更为复杂的计算</p>
</li>
<li><p>可以自动化更为复杂和更为困难的事</p>
<p>闲聊：卡车问法拉利司机，你的车能拉多少吨货，不要把自己的长处和别人的短处比。</p>
</li>
</ul>
</li>
<li><p>会成为主流技术的特征</p>
<ul>
<li><p>有大公司做背书</p>
</li>
<li><p>有杀手级应用</p>
</li>
<li><p>有强大的社区  </p>
<p>闲聊：Go是google发明的，解决了java难用的问题，提升了并发编程的能力，社区强大；ruby社区不行。java不会被Go取代。Python一般。大数据挺好，更偏算法，分两块，基础层的，数学模型算法层的。</p>
</li>
</ul>
</li>
</ol>
<h4 id="第三部分-找到方法，事半功倍"><a href="#第三部分-找到方法，事半功倍" class="headerlink" title="第三部分 找到方法，事半功倍"></a>第三部分 找到方法，事半功倍</h4><h5 id="主动学习-VS-被动学习"><a href="#主动学习-VS-被动学习" class="headerlink" title="主动学习 VS 被动学习"></a>主动学习 VS 被动学习</h5><h5 id="学习的一些观点"><a href="#学习的一些观点" class="headerlink" title="学习的一些观点"></a>学习的一些观点</h5><ol>
<li>学习是为了找到方法<ul>
<li>学习不是找答案，而是找到通往答案的方法</li>
</ul>
</li>
<li>学习是为了认识原理和本质<ul>
<li>理解原理和本质就可以一通百通</li>
</ul>
</li>
<li>学习是为了打开自己的认知<ul>
<li>你不知道你不知道的东西</li>
</ul>
</li>
<li>学习是为了改善自己<ul>
<li>思维方式 - 更为的逻辑和科学</li>
<li>行动方式 - 更为的高效</li>
</ul>
</li>
</ol>
<h5 id="学习的相关方法"><a href="#学习的相关方法" class="headerlink" title="学习的相关方法"></a>学习的相关方法</h5><ol>
<li><p>挑选知识和信息源 </p>
<ul>
<li>第一手资料非常重要（英文非常重要）</li>
</ul>
</li>
<li>注意基础和原理</li>
</ol>
<ul>
<li>我可以忘了这个技术，但是我可以自己徒手打造出来 </li>
</ul>
<ol start="3">
<li>使用知识图系统的学习 （read the fucking menu）</li>
</ol>
<ul>
<li>通过知识关联可以进行“顺藤摸瓜”</li>
</ul>
<ol start="4">
<li><p>举一反三</p>
<ul>
<li><p>用不同的方法学同一个东西</p>
</li>
<li><p>学一个东西时把周边的也学了</p>
<p>学http也看看http1/http2/socked/Tcp/Ip</p>
</li>
</ul>
</li>
<li><p>总结和归纳</p>
</li>
</ol>
<ul>
<li>形成框架、套路和方法论</li>
</ul>
<ol start="6">
<li><p>实践和坚持</p>
<ul>
<li>实践才能把知识变成技能，坚持才能有沉淀</li>
</ul>
</li>
</ol>
<h5 id="学习的一些技巧"><a href="#学习的一些技巧" class="headerlink" title="学习的一些技巧"></a>学习的一些技巧</h5><ol>
<li><p>如何阅读代码</p>
<ul>
<li>基础知识、文档、代码结构</li>
<li>模块、接口、关键业务路径</li>
<li>代码逻辑、运行时调试</li>
</ul>
</li>
<li><p>如何面对枯燥和硬核的知识</p>
<ul>
<li><p>找到应用场景和牛人</p>
</li>
<li><p>补充基础知识</p>
</li>
<li><p>咬牙使劲啃    </p>
<p>啃一本硬核的书，看自己能不能完成，看看完成后是不是多巴胺分泌上升，是不是兴奋，而不是说卧槽程序员坑真多啊 </p>
</li>
</ul>
</li>
<li><p>其它小技巧  </p>
<ul>
<li>不要记忆</li>
<li>把信息压缩</li>
<li>经常犯错</li>
<li>写blog</li>
<li>它山之石可以攻玉  </li>
</ul>
</li>
</ol>
<h4 id="闲聊："><a href="#闲聊：" class="headerlink" title="闲聊："></a>闲聊：</h4><ol>
<li>关手机是个重要的事，做到不被打扰。最短作业先处理，整块时间留给重要的事。</li>
<li><p>问产品经理你到底要解决什么问题，可以减少70%的需求。</p>
</li>
<li><p>年龄问题：</p>
<ul>
<li>20-30要敢于冒险。多学习。</li>
<li>30-40职业成长的最后十年</li>
<li>40-50 还可以折腾的最后十年</li>
<li>50-60 还有精力的十年</li>
</ul>
</li>
<li><p>一定要上升到更高的层次，不能一直搬砖，你搬不过25岁的那些人，对一个领域要精通或者做一个管理者。</p>
</li>
<li><p>推荐算法主要是找关联信息，例如：抽象出哪个商品和哪个商品有关联。</p>
</li>
<li><p>要成为自由职业者，坚持把原理吃透了，多写博客，树立影响力，教别人，别人有问题能来找你。弄绝大多数人不会的。</p>
</li>
<li><p>区块链不可能成。</p>
</li>
<li>Node.js别玩，php没前途，php转go自然点。</li>
<li>Java像是有城市规划，其他的语言都是拼凑，没有什么架构，一堆东西在拼凑。</li>
<li>但是要不要学，当然都要学，但是要确定好吃饭的那一个 。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/并查集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/26/并查集/" itemprop="url">并查集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-26T17:00:42+08:00">
                2019-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/并查集.png" style="zoom:30%;"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/Trie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WarriorYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarriorYu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/19/Trie/" itemprop="url">Trie（字典树、前缀树）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T18:22:02+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/什么是Trie.png" style="zoom:30%;"></p>
<p><img src="/images/什么是Trie2.png" style="zoom:30%;"></p>
<p><img src="/images/压缩字典树.png" style="zoom:30%;"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="WarriorYu" />
            
              <p class="site-author-name" itemprop="name">WarriorYu</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry. Stay Foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/WarriorYu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="soldieryu.dev@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WarriorYu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
