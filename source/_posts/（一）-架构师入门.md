---
title: （一） 架构师入门
categories:
  - 架构
tags:
  - 架构
date: 2020-08-05 10:53:41
---

# 1. 架构师入门

### 一. AOP面向切面架构设计-两种方式

1. 定义：

   在软件业，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程](https://baike.baidu.com/item/面向切面编程/6016335)，通过[预编译](https://baike.baidu.com/item/预编译/3191547)方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是[OOP](https://baike.baidu.com/item/OOP)的延续，是软件开发中的一个热点，也是[Spring](https://baike.baidu.com/item/Spring)框架中的一个重要内容，是[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938)降低，提高程序的可重用性，同时提高了开发的效率。

2. aspectj：

   - 编译时用Aspect专门的编译器，不再使用传统的javac 

3. aspectj相关：

   - 下载aspectj  地址   http://www.eclipse.org/aspectj/downloads.php

   - 下载aspectj的adt地址http://www.eclipse.org/ajdt/downloads/#43zips


   - build.gradle  aspectJ  写法  http://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/

### 二. 设计模式

1. MVC:  如果Activity里有线程执行耗时操作没有执行完，但是退出Activity,这时Activity不会被回收，导致内存泄漏。
2. MVP：Activity使用弱引用，当有耗时操作时，退出Activity时不会发生内存泄漏。
   - 第一种P层的实现：Google在Github开源的架构实例，M对应JavaBean，V对应Activity/Fragment, P处理业务逻辑等，所有的活都有P层干完，然后通知V更新UI。
   - 第二种P层的实现：P层只做转发，M对应Model层，P转发给M层处理业务逻辑等，然后M再返回给P层，P层通  知V层更新UI。
   - 第三种P层的实现：类似第二种，但是不需要Model层，让功能模块去工作（LIibrary:下载、请求、图片加载）。
3. MVVM：
   1. 缺点  
      - 虽然不用findViewById，但是view都放在一个Object数组里，Activity有很多，就有很多数组，这是第一个占用内存过多的地方。 
      - 在ViewDataBinding类的static代码块里，在每个Activity都有OnAttachStateChangeListener对每个View做状态改变的监听，状态改变都会调用他的onViewAttachedToWindow方法，从该方法里能看到在ViewDataBinding类里new了Runnable，也就是创建了线程，可见Activity多的时候，会因为每个Activity都new了一个Runnable，线程过多导致内存占用过大。这是第二个占用内存的地方。
      - 在ViewDataBinding类的invalidateAll()方法，还有一些其他的地方，里面使用了Handler，因为Handler绑定了Looper，每个Activity都这样，占用内存过多。这是第三个占用内存的地方。 
   2. M->V  V->M的过程解析
      - ViewDataBinding类的static快里，执行了binding.mRebindRunnable.run();跟着方法走，可以看到executePendingBindings() ->executeBindingsInternal() ->executeBindings()，executeBindings这个方法在ActivityMainBindingImpl实现，里面可以跟踪看到M更新V，V更新M。 

### 三. Android 系统源码

#### 1. Handler: 为什么在子线程可以使用textView.setText() 不报错，使用Toast报错。

- 首先这个问题不是绝对的，如果在textView.setText() 之前sleep几秒，同样会报错。

- 因为setText()方法的过程中，会在ViewRootImpl类中执行一个checkThread方法，来检查当前线程和创建ViewRootImpl时的线程是不是同一个线程；而ViewRootImpl的创建是在onResume方法中初始化的，而我们开启的子线程是在onCreat方法中，这个时候程序没有去检测当前线程是不是主线程，所以没有抛异常。因为Toast也有setText方法，但是在这个方法之前还有一些其他操作，等执行到检查线程的方法时，ViewRootImpl已经初始化好了。如果我们在TextView.setText之前sleep一秒，就会报错，因为ViewRootImpl已经初始化好了，会检查线程。

#### 2.Binder

​    1.  Binder可以实现进程与进程之间的通信。